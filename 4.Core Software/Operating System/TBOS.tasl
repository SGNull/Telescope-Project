JMP >Init
(%
  TBOS v1.0
  ---------
  
  TSOS is a small-scale operating system for the Telescope Computer System.
  It will intentionally be written with as few "magic numbers" as possible for maximum versatility.
  It would be very difficult to let empty arrays be defined using labels in TASL, so instead comments are added for clarification.
  
  v1.0 Adds the foundations for the operating system, which includes:
	Program starting and memory allocation.
	Process stopping and memory deallocation.
	Multiprogramming (though not multithreading).
	Process family tree.
  
  With the specs:
    16 max processes.
	Round robin process scheduling.
	First open spot is allocated in memory.
	Memory allocation/deallocation via 4-word bitmap.
    Memory allocation bitmap includes OS occupied chunks (stack + code).

  Here is how exceptions are handled:
	Interrupts: Not supported (OS will error)
    CTDZ: Pauses the current process and runs the next one.
    SYS: Tries to spawn a process as a child of the current one. If successful, returns 1, else it returns NULL.
	PRIV: Terminates the current process and all of its children.
	OOB: Terminates the current process and all of its children.
  
  v1.0 is especially small-scale, and future versions will modify 1.0 to achieve higher functions.
%)

(/ ------------------------------------------------------------Data------------------------------------------------------------
(/ ------- Hardware constants -------
@WORD_SIZE = 16  / Word size in bits (always must be 16)
@STATE_REG_COUNT = 12  / Number of registers which should be stored (always 12)

@DRIVE_IOP_GROUP = 0
@DRIVE_PTR_IOP_GROUP = 1
@IOP_GROUP_MASK = 0xE000
@IOP_GROUP_SHIFT = 13
@DRIVE_PTR_BIT = 0x2000

@HI_SHIFT = 8
@LO_SHIFT = >HI_SHIFT
@LO_MASK = 0x00FF

@EXC_MASK = 0x0700
@EXC_SHIFT = 8

@PC_STATUS_IOP = 0xF000
@RANDOM_IOP = >PC_STATUS_IOP

@ENDLOAD = 0xF33D
)


(/ ------- OS Properties & Data -------
/ Process = [1-bit Active] [4-bit parent] [4-bit nextSib] [4-bit child]
/ NOTE: This could be modified to support 32 procs, but memory conflicts will start occurring.
@MAX_PROC_COUNT = 16
@PROC_WORDS = 1  / must be under 16

@USER_PROC_FLG = 0x000C

@PROC_ACTIVE_BIT = 15
@PARENT_MASK = 0xF00
@PARENT_SHIFT = 8
@SIB_MASK = 0xF0
@SIB_SHIFT = 4
@CHILD_MASK = 0xF

@CHUNK_SIZE = 0x0400  / cannot be over 0x1600
@HLB_REL_CHUNK_SIZE = 4  / must be CHUNK_SIZE/0x0100
@NUM_CHUNKS = 64  / Must be (2^16)/CHUNK_SIZE
@BMP_WORDS = 4  / Must be NUM_CHUNKS/16, and under 16
#MallocBMPs = (~4)  / Must have size of BMP_WORDS

/ 16 max proc x 1 word per proc = 16 words
#ProcList = ~16

@ROOT_PROC_ID = 0  / Must be 0
@NULL_PROC_ID = >ROOT_PROC_ID  / Must be ROOT_PROC_ID

@ROOT_DRIVE_IOP = 0x0000

/ Number of current active procs
#ProcCount = 0

/ We need to know what the current procID is.
#CurrentProcID = 0

/ Each process needs all registers stored except for PC, IO, EXA, and CTD
/ 16 max proc x 12 reg per proc = 192
/ Each state has the following format: RG0-7, FLG, SP, EPC, HLB
#StateList = ~192
@FLG_OFFSET = 8
@SP_OFFSET = 9
@EPC_OFFSET = 10
@HLB_OFFSET = 11

/ Where (some of) the state of the CPU is immediately stored at.
/ EPC and HLB are not stored
#TState = (~10)

#MarkInst: ALU SET RG5 RG4
#UnmarkInst: ALU UST RG5 RG4
)


(/ ------- Status Codes -------
@START_CODE 			= 1
@RUN_CODE 			= 2
@END_CODE 			= 0x600D

@BAD_START_ERROR 		= 0xFF00
@UNKNOWN_EXC_ERROR 	= 0xFF01
)
)

/ ------------------------------------------------------------Code------------------------------------------------------------



/ Initializes the OS environment (may have to remove the bootloader too, and zero out some key registers)
(#Init
	/ Set the status
	LDI RG0 >START_CODE; LDI FLG >PC_STATUS_IOP; MOV IO RG0
	
	/ Remove the bootloader
	ZRO RG0; ZRO RG1; LDI RG2 >ENDLOAD
	#Ini.CleanLoop
		DEC RG1; LOD RG3 RG1 0
		STR RG0 RG1 0
	CMP RG3 RG2; JNE >Ini.CleanLoop
	
	/ Calculate the OS size in chunks in RG1
	LDI RG1 >OSEndPoint; LDI RG0 >CHUNK_SIZE; ALU DIV RG1 RG0
	ALI ADD RG1 1  / Add the stack chunk
	
	/ Put the start chunk in RG0 and call MarkBits
	LDI RG0 >NUM_CHUNKS; ALI SUB RG0 1  / Adjust for stack (will be at end of mem)
	CAL >MarkBits
	
	/ Spawn the root process (by hand)
	
	
	/ Set the new status
	LDI RG0 >RUN_CODE; LDI FLG >PC_STATUS_IOP; MOV IO RG0
	
	/ Send control off to the dispatcher
	JMP >Dispatcher
)



/ The OS has ran successfully and the machine should be stopped.
(#FinishLine
	
)



/ Sets the status to RG0 and halts
(#Error
	LDI FLG >PC_STATUS_IOP
	MOV IO RG0
	HLT
)



/ The scheduler/dispatcher runs the next process (and checks for done/deadlock/etc.)
(#Dispatcher
	
)



/ Retires the previous process, then jumps to Dispatcher
/ RG0-2 and FLG are already stored
(#BurstOver	
	/ Get current proc's actual state address in RG0
	ZRO RG0; LOD RG0 RG0 >CurrentProcID; ALI MUL RG0 >STATE_REG_COUNT
	LDI RG1 >StateList; ALU ADD RG0 RG1
	
	/ Put TState's address in RG1
	LDI RG1 >TState
	
	/ Copy (what's currently in) TState to the current state
	LOD RG2 RG1 0; STR RG2 RG0 0
	LOD RG2 RG1 1; STR RG2 RG0 1
	LOD RG2 RG1 2; STR RG2 RG0 2
	LOD RG2 RG1 >FLG_OFFSET; STR RG2 RG0 >FLG_OFFSET
	
	/ Now copy the rest of the registers to the current state
	/ Note: HLB is constant
	STR RG3 RG0 3
	STR RG4 RG0 4
	STR RG5 RG0 5
	STR RG6 RG0 6
	STR RG7 RG0 7
	STR SP RG0 >SP_OFFSET
	STR EPC RG0 >EPC_OFFSET
	
	/ Now return control to the dispatcher
	JMP >Dispatcher
)



/ Resume the current process *NOT A FUNCTION*
(#ResumeProc
	/ Restore the temp state
	LDI RG0 >TState
	LOD SP RG0 >SP_OFFSET
	LOD FLG RG0 >FLG_OFFSET
	LOD RG7 RG0 7
	LOD RG6 RG0 6
	LOD RG5 RG0 5
	LOD RG4 RG0 4
	LOD RG3 RG0 3
	LOD RG2 RG0 2
	LOD RG1 RG0 1
	LOD RG0 RG0 0
	
	/ Resume the process
	RSM
)



/ Handles any exceptions that occur
(#ExHandler
	/ Store off RG0-2 and FLG for CTDZ
	STR RG0 RG0 >TState
	LDI RG0 >TState
	STR RG1 RG0 1
	STR RG2 RG0 2
	STR FLG RG0 >FLG_OFFSET
	
	/ Check if it's CTDZ
	LDI RG0 >EXC_MASK; ALU AND RG0 FLG; ALI SRB RG0 >EXC_SHIFT
	CMI RG0 >EXC_CTDZ; JEQ >BurstOver
	
	/ Check if it's unrecoverable
	CMI RG0 >EXC_PRIV; JEQ >EndProc
	CMI RG0 >EXC_OOB; JEQ >EndProc
	
	/Store off the rest of the registers
	LDI RG0 >TState
	STR RG3 RG0 3
	STR RG4 RG0 4
	STR RG5 RG0 5
	STR RG6 RG0 6
	STR RG7 RG0 7
	/ FLG is already stored
	STR SP RG0 >SP_OFFSET
	ZRO SP
	
	/ Get EXC again
	LDI RG0 >EXC_MASK; ALU AND RG0 FLG; ALI SRB RG0 >EXC_SHIFT
	
	/ Check for Syscall
	CMI RG0 >EXC_SYS; JEQ >SpawnProc
	
	/ Else, error
	LDI RG0 >UNKNOWN_EXC_ERROR
	JMP >Error
)



/ Calls terminate on the current process then jumps to the dispatcher
(#EndProc
	ZRO RG0; LOD RG0 RG0 >CurrentProcID; NUL RG1
	CAL >Terminate
	JMP >Dispatcher
)



/ (ProcID, IsStart? NULL/0 Y/N) 
/ Terminates the process and all of its child procs, and removes from family tree if IsStart
/ Modifies RG0-5 and FLG
/ When threads are added, assuming there is a parent, if parent HLB is equal, don't deallocate
(#Terminate
	/ This function calls a few others, so push the RA to the stack
	PSH 1; STR RA SP 0
	
	/ Step 1: Get the actual index
	ALI MUL RG0 >PROC_WORDS
	PSH 1; STR RG0 SP 0  / Storing it on the stack
	
	/ Step 2: Get the process' main word in RG0
	LOD RG0 RG0 >ProcList
	
	/ Step 3: Remove process from family tree (cases: is root, is only child, has siblings)
	/ Check if IsStart
	(PAS RG1; JIF EQZ >Ter.SkipTree
	
	/ Check if root (root is 0 so we don't need to div)
	LOD RG1 SP 0; CMI RG1 >ROOT_PROC_ID; JEQ >Ter.SkipTree
	
		/ Get parent word in RG2, and actual index in RG1
		MOV RG1 RG0
		LDI RG2 >PARENT_MASK; ALU AND RG1 RG2; ALI SRB RG1 >PARENT_SHIFT
		ALI MUL RG1 >PROC_WORDS; LOD RG2 RG1 >ProcList
		
		/ Check if only child
		LDI RG3 >CHILD_MASK; ALU AND RG3 RG2
		LOD RG4 SP 0; ALI DIV RG4 >PROC_WORDS
		CMP RG3 RG4; JEQ >Ter.OnlyChild
		
			/ Not only child, so find proc as sibling
			/ RG2: Current process word
			/ RG3: Actual index of current process
			/ RG4: Key
			/ RG5: Next ProcNum
			MOV RG5 RG3
			
			#Ter.FindLoop
				MOV RG3 RG5
				ALI MUL RG3 >PROC_WORDS; LOD RG2 RG3 >ProcList
				LDI RG5 >SIB_MASK; ALU AND RG5 RG2; ALI SRB RG5 >SIB_SHIFT
			CMP RG5 RG4; JNE >Ter.FindLoop
			
			/ Found, so remove by bridging
			LDI RG5 >SIB_MASK; ALU NOT RG4 RG5; ALU AND RG5 RG0
			ALU AND RG2 RG4; ALU OR RG2 RG5; STR RG2 RG3 >ProcList
			JMP >Ter.SkipTree
		
		#Ter.OnlyChild
		LDI RG3 >CHILD_MASK; ALU NOT RG3 RG3
		ALU AND RG2 RG3; STR RG2 RG1 >ProcList
			
	)#Ter.SkipTree
	
	/ Step 4: Call Terminate on child procs (if they exist)
	LDI RG1 >CHILD_MASK; ALU AND RG1 RG0
	CMI RG1 >NULL_PROC_ID; JEQ >Ter.NoChild
		PSH 1; STR RG0 SP 0
		MOV RG0 RG1; NUL RG1; CAL >Terminate
		LOD RG0 SP 0; POP 1
	#Ter.NoChild
	
	/ Step 5: Call Terminate on sibling procs (if they exist)
	LDI RG1 >SIB_MASK; ALU AND RG1 RG0; ALI SRB RG1 >SIB_SHIFT
	CMI RG1 >NULL_PROC_ID; JEQ >Ter.NoSib
		PSH 1; STR RG0 SP 0
		MOV RG0 RG1; NUL RG1; CAL >Terminate
		LOD RG0 SP 0; POP 1
	#Ter.NoSib
	
	/ Step 6: Deactivate the proc
	LOD RG1 SP 0; POP 1
	ALI UST RG0 >PROC_ACTIVE_BIT; STR RG0 RG1 >ProcList
	
	/ Step 7: Deallocate its memory
	/ Get HLB
	ALI DIV RG1 >PROC_WORDS
	ALI MUL RG1 >STATE_REG_COUNT; ALI ADD RG1 >STATE_HLB_INDEX
	LOD RG0 RG1 >StateList
	
	/ Get size & start bit in the BMP
	MOV RG1 RG0; ALI SRB RG1 >HI_SHIFT; ALI DIV RG1 >HLB_REL_CHUNK_SIZE
	LDI RG2 >LO_MASK; ALU AND RG0 RG2; ALI DIV RG0 >HLB_REL_CHUNK_SIZE
	
	/ Call UnmarkBits(Start, Size)
	CAL >UnmarkBits
	
	/ Step 8: Return
	LOD RA SP 0; POP 1
	RET
)



/ Ensures we can spawn a process, allocates resources, calls MakeChildProc, then resumes the current one.
(#SpawnProc
	/ Step 1: make sure IOP is configured properly
	LDI RG0 >TState; LOD RG0 RG0 >FLG_OFFSET; MOV FLG RG0
	LDI RG1 >IOP_GROUP_MASK; ALU AND RG0 RG1; ALI SRB RG0 >IOP_GROUP_SHIFT
	CMI RG0 >DRIVE_IOP_GROUP; JNE >SpP.Error
	
	/ Step 2: make sure that we aren't running the max number of procs
	ZRO RG0; LOD RG0 RG0 >ProcCount
	LDI RG1 >MAX_PROC_COUNT; CMP RG1 RG0; JEQ >SpP.Error
	
	/ Step 3: calculate the size of the program (in chunks)
	MOV RG0 IO
	LDI RG1 >CHUNK_SIZE; ALU DIV RG0 RG1; INC RG0
	
	/ Step 4: check memory to see where it will fit
	CAL >FindOpenMemory
	AIN ADD OUT 1; JIF CAR >SpP.Error
	
	/ Step 4.1: Calculate HLB for step 6 while we have the values
	MOV RG1 RG0; ALI SLB RG1 >HI_SHIFT
	MOV RG2 OUT; LDI RG3 >CHUNK_SIZE; ALU MUL RG2 RG3
	ALU OR RG1 RG2
	
	/ Put HLB on the stack
	PSH 1; STR RG1 SP 0
	
	/ Step 5: mark memory spots
	MOV RG1 RG0
	MOV RG0 OUT
	CAL >MarkBits
	
	/ Step 6: Move into memory
	LOD RG0 SP 0; POP 1
	CAL >LoadProgram
	
	/ Step 7: call MakeChildProc(HLB,USER_PROC_FLG) (configure current PCB and make new one)
	LDI RG1 >USER_PROC_FLG
	CAL >MakeChildProc
	
	/ Step 8: Resume current process (and set its OUT to 1)
	LDI RG0 1; LDI RG1 >TState; STR RG0 RG1 >TState.OUT;
	JMP >ResumeProc
	
	/ Something went wrong, so put NULL in output and resume
	#SpP.Error
	NUL RG0; LDI RG1 >TState; STR RG0 RG1 >TState.OUT;
	JMP >ResumeProc
)



/ (HLB value, FLG value) Creates a new process as a child of CurrentProcID
/ Modifies RG0-5, and FLG
(#MakeChildProc
	/ Step 1: Get a new PCB for the new proc
	/ RG2: PCB Main Word
	/ RG3: ProcNum
	/ RG4: Temp
	
	/ Find next available PCB
	NUL RG3  / Set RG3 to -1
	#MCP.FindLoop
		INC RG3
		MOV RG4 RG3; ALI MUL RG4 >PROC_WORDS
		LOD RG2 RG4 >ProcList
	AIN SET RG2 >PROC_ACTIVE_BIT; JIF CAR >MCP.FindLoop
	
	/ Step 2: Set up all the values for the PCB
	/ Set all the values in the PCB
	ZRO RG2; AIN SET RG2 >PROC_ACTIVE_BIT
	ZRO RG4; LOD RG4 RG4 >CurrentProcID
	ALI SLB RG4 >PARENT_SHIFT; ALU OR RG2 RG4
	
	/ Store the values in the PCB
	MOV RG4 RG3; ALI MUL RG4 >PROC_WORDS
	STR RG2 RG4 >ProcList
	
	/ Step 3: Set up the state values
	/ RG2: True index in States array
	/ RG3: Index in the state
	/ RG5: Procnum moved here
	MOV RG2 RG3; LDI RG4 >STATE_REG_COUNT; ALU MUL RG2 RG4
	MOV RG5 RG3
	
	/ State order: RG0, RG1, ..., SP, FLG, HLB, EPC
	/ Zero everything out
	ZRO RG3; ZRO RG4
	#MCP.StateLoop
		STR RG4 RG2 >StateList
		INC RG2; INC RG3
	CMI RG3 >STATE_REG_COUNT; JNE >MCP.StateLoop
	
	/ Set FLG and HLB
	ALI SUB RG2 >STATE_REG_COUNT; ALI ADD RG2 >STATE_FLG_INDEX
	STR RG1 RG2 >StateList
	ALI SUB RG2 >STATE_FLG_INDEX; ALI ADD RG2 >STATE_HLB_INDEX
	STR RG0 RG2 >StateList
	
	/ Step 4: Handle the 2 cases for making current proc child
	/ Get the current proc's PCB main word in RG0 (RG4 has actual index)
	ZRO RG4; LOD RG4 RG4 >CurrentProcID
	ALI MUL RG4 >PROC_WORDS
	LOD RG0 RG4 >ProcList
	
	/ Get current proc's child proc in RG1
	LDI RG2 >PARENT_MASK; MOV RG1 RG0; ALU AND RG1 RG2
	ALI SRB RG1 >PARENT_SHIFT
	
	/ Check cases
	CMI RG1 >NULL_PROC_ID; JNE >MCP.HasChild
		/ Case 1: it does not have a child
		/ Set the new proc as the child & return
		ALU OR RG0 RG5; STR RG0 RG4 >ProcList
		RET
	#MCP.HasChild
	
	/ Case 2: it has a child already
	/ Get the child/sib proc's pcb main word and check its sib (RG1 has actual index)
	#MCP.InsertLoop
		ALI MUL RG1 >PROC_WORDS; LOD RG0 RG1 >ProcList
		MOV RG2 RG0; ALI AND RG2 >SIB_MASK; ALI SRB RG2 >SIB_SHIFT
		/ If it has a sib, loop
	CMI RG2 >NULL_PROC_ID; JNE >MCP.InsertLoop
	
	/ Now insert the new proc as a sibling
	ALI SLB RG5 >SIB_SHIFT; ALU OR RG0 RG2; STR RG0 RG1 >ProcList
	RET
)



/ (HLB), loads the program from FLG's IOP
/ Modifies RG1-2 and FLG
(#LoadProgram
	/ RG1 - Start
	/ RG2 - Size
	LDI RG1 >LO_MASK; ALU AND RG1 RG0; ALI SLB RG1 >LO_SHIFT
	ZRO RG2; ALI SET FLG >DRIVE_PTR_BIT; MOV IO RG2
	ALI UST FLG >DRIVE_PTR_BIT; MOV RG2 IO
	#LoP.LoadLoop 
		STR IO RG1 0
		INC RG1
	DEC RG2; JIF NEZ >LoP.LoadLoop
	RET
)



/ (Size), returns the number of the first 0 bit
/ Modifies RG1-5, and FLG
(#FindOpenMemory
	/ RG1: Current bitwise index
	/ RG2: Relative bitwise index to RG1
	/ RG3: Current word
	/ RG4: WORD_SIZE
	/ RG5: Temp register
	/ RG6: Temp register
	ZRO RG1; LOD RG3 RG1 >MallocBMPs; LDI RG4 >WORD_SIZE
	
	#FOM.Loop
		/ If current bit (calculate in RG5) is 0, start the inner loop
		MOV RG5 RG1; ALU MOD RG5 RG4
		AFN SET RG3 RG5; JIF CAR >FOM.Not0
			
			/ Set up RG2 as relative index, and
			/ RG5: current actual index
			LDI RG2 1
			MOV RG5 RG1; ALU ADD RG5 RG2
			#FOM.InLoop
				/ If RG0 number of 0's were found, we're done
				CMP RG2 RG0; JEQ >FOM.Success
				
				/ If not, check if we need to go to the next word for the next bit
				AFN MOD RG5 RG4; JIF EQZ >FOM.SameWord
					/ Not the same word, so grab the new one.
					MOV RG6 RG5; ALU DIV RG6 RG4; ALI MOD RG6 >BMP_WORDS
					LOD RG3 RG6 >MallocBMPs
				#FOM.SameWord
				
				/ Now check the next bit
				MOV RG6 RG5; ALU MOD RG6 RG4
				AFN SET RG3 RG6; JIF CAR >FOM.Hit1
				
			/ If it's 0, increment RG5 and RG2
			INC RG5; INC RG2; JMP >FOM.InLoop
				
			/ Else, if it's 1, exit the loop
			#FOM.Hit1
			MOV RG1 RG5  / Update RG1 to be accurate (it will then increment past the 1)
			
		#FOM.Not0
		
		/ Increment the current index, and check if it's over the total bits
		INC RG1; LDI RG5 >NUM_CHUNKS; CMP RG5 RG1; JLT >FOM.NoSpace
		
		/ If not, get the next word if needed and loop
		AFN MOD RG1 RG4; JIF NEZ >FOM.Loop
		MOV RG5 RG1; ALU DIV RG5 RG2; LOD RG3 RG5 >MallocBMPs  / Get next word
	JMP >FOM.Loop
	
	#FOM.Success
	MOV OUT RG1; RET
		
	#FOM.NoSpace
	NUL OUT; RET
)



/ (Start, Size), turns on bits Start through Start+Size-1 inclusive
/ Modifies RG1-5, and FLG
(#MarkBits
	/ Setup and jump to ModifyBits
	ZRO RG2; LOD RG2 RG2 >MarkInst; STR RG2 RG2 >MoB.ModBit
	JMP >ModifyBits
)

/ (Start, Size), turns off bits Start through Start+Size
/ Modifies RG1-5, and FLG
(#UnmarkBits
	/ Setup and jump to ModifyBits
	ZRO RG2; LOD RG2 RG2 >UnmarkInst; STR RG2 RG2 >MoB.ModBit
	JMP >ModifyBits
)

/ Shell function for UnmarkBits and MarkBits DO NOT CALL
(#ModifyBits
	/ RG2 is WORD_SIZE, RG3 is word num, RG4 is bits, RG5 is the word itself
	LDI RG2 >WORD_SIZE
	MOV RG3 RG0; ALU DIV RG3 RG2
	LOD RG5 RG3 >MallocBMPs
	MOV RG4 RG0; ALU MOD RG4 RG2
	
	/ Now loop through the bitmap and unset bits
	#MoB.Loop
		/ Modify the bit
		#MoB.ModBit:NOP
		
		/ Goto the next bit (unless we're at the end, or end of word)
		INC RG4; DEC RG1; JIF EQZ >MoB.Done
		ALF MOD RG4 RG2; JIF NEZ >MoB.Loop
		
		/ If at the end of word, store the word and get the next one
		STR RG5 RG3 >MallocBMPs; INC RG3; ALI MOD RG3 >BMP_WORDS
		LOD RG5 RG3 >MallocBMPs
		JMP >MoB.Loop
	#MoB.Done
	
	/ Now that we're done, update the last word and return
	STR RG5 RG3 >MallocBMPs
	RET
)



/ The end of the OS's code segment in memory
#OSEndPoint
