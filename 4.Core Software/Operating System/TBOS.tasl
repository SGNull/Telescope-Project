JMP >Init
%
  TBOS v1.0
  ---------
  
  TSOS is a small-scale operating system for the TelGen Computer System.
  It will intentionally be written with as few "magic numbers" as possible for maximum versatility.
  It would be very difficult to let empty arrays be defined using labels in TASL, so instead comments are added for clarification.
  
  v1.0 Adds the foundations for the operating system, which includes:
	Program starting and memory allocation.
	Process stopping and memory deallocation.
	Multiprogramming (though not multithreading).
	Process family tree.
  
  With the specs:
    16 max processes.
	Round robin process scheduling.
	First open spot is allocated in memory.
	Memory allocation/deallocation via 4-word bitmap.
    Memory allocation bitmap includes OS occupied chunks (stack + code).
  
  v1.0 is especially small-scale, and future versions will modify 1.0 to achieve higher functions.
%

/ ------------------------------------------------------------Data------------------------------------------------------------

/ Process = [1-bit Active] [4-bit parent] [4-bit nextSib] [4-bit child]
/ NOTE: This could be modified to support 32 procs, but memory issues will start occurring.
@MAX_PROC = 16

@PARENT_MASK = 0xF00
@PARENT_SHIFT = 8
@SIB_MASK = 0xF0
@SIB_SHIFT = 4
@CHILD_MASK = 0xF

@NUM_CHUNKS = 64
@BMP_WORD_BITMASK = 0b110000
@BMP_WORD_MOD = 4		/ Cannot be over 15
@BMP_WORD_SHIFT = 4		/ Should be the same \/
@BMP_BITS_MAXBIT = 4		/ Should be the same /\
@BMP_BITS_BITMASK = 0b001111

/ 16 max proc x 1 word per proc = 16 words
#ProcList = ~16

/ Number of current active procs
#ProcCount = 0

/ Each process needs all registers stored except for PC, IO, EXA, and EPC
/ 16 max proc x 12 reg per proc = 192
#StateList = ~192

/ We need to know what the current procID is.
#CurrentProc = 0

/ ------------------------------------------------------------Code------------------------------------------------------------



/ Initializes the OS environment (may have to remove the bootloader too, and zero out some key registers)
#Init
	



/ We need an entry point to return to.
/ While this may be somewhat confusing, remember we don't have a BIOS to store the previous process somewhere
/ That's where this function comes in. It sets up the OS after an exception, for the exception handler to take over.
#Entry



/ One thing we need is something to dispatch processes
#Dispatcher



/ We also need something to handle exceptions
#ExHandler



/ We will need something to terminate processes
#Terminate



/ Something has to spawn new processes
#SpawnProc


/ (Start, Size), Turns off bits Start through Start+Size
(#ClearMem

	/ RG3 is word num, RG4 is bits, RG5 is the word itself
	LDI RG2 >BMP_WORD_BITMASK; MOV RG3 RG0; ALU AND RG3 RG2
	ALI SRB RG3 >BMP_WORD_SHIFT
	LOD RG5 RG3 >MallocBMPs
	LDI RG2 >BMP_BITS_BITMASK; MOV RG4 RG1; ALU AND RG4 RG2
	
	#ClMm.Loop
		/ Zero out that bit
		ZRO RG2; INC RG2; ALU SLB RG2 RG4; ALU NOT RG2 RG2
		ALU AND RG5 RG2
		
		/ Go to the next bit (unless we're done)
		DEC RG1; JIF EQZ >ClMm.Done
		INC RG4; AIN SEL RG4 >BMP_BITS_MAXBIT; JIF EQZ >ClMm.Loop
		
		/ If we're here, we need to go to the next word in the BMP
		ZRO RG4; STR RG5 RG3 >MallocBMPs; INC RG3; ALI MOD RG3 >BMP_WORD_MOD
		
	
	#ClMm.Done
	STR RG5 RG3 >MallocBMPs
)