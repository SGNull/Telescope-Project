JMP >Init

(% 	TBOS v2.1
	---------
  
	TSOS is a small-scale operating system for the Telescope Computer System.
	It will intentionally be written with as few "magic numbers" as possible for maximum versatility.
	
	TBOS v2.0 is a complete overhall of TBOS, fullfilling most of the features that PandOS does at phases 2 and 3.
	Because of this, TBOS begins to stand out as its own operating system.
	The following are all true for v2.0:
		All interrupts are supported.
			- TICK can be waited on by procs using the WAIT_TICK syscall.
			- PAUS calls the PauseMenu function (just pauses the comptuer, will definitely improve in the future).
			- PVIO just returns an error code to the user process.
			- STOP calls the Shutdown function (terminates root, might improve in the future).
		
		The following syscalls are implemented (K means it requires Kernel, and the parentheses denote extra args):
		
		0 K LOAD_PROGRAM(fileNumber, Kernel?) w/ IOP: 
			- Requires IOP to be looking at the drive. 
			- Takes a file number and whether the thread should be kernel.
				* If file number is -1, reads file as loadable.
			- Possible results: No space available, max threads, success
		1 SPAWN_THREAD(function, SP, Kernel?):
			- Needs three things: PC, SP, and whether the thread should be kernel.
			- Possible results: Max threads, success
		2 TERMINATE():
			- Terminates the current process (self)	
		3 GIVE_UP_TURN():
			- Stops the thread's current burst here.
		4 PASSEREN(semAdd):
			- Wait
			- Possible results: address OOB, success
		5 VERHOGEN(semAdd):
			- Signal
			- Possible results: address OOB, success
		6 IO_MUTEX() w/ IOP:
			- Passeren the given IOP's mutex semaphore.
			- Possible results: privileged I/O, success
		7 IO_RELEASE() w/ IOP:
			- IO_WAIT, but with VERHOGEN
			- Possible results: privileged I/O, success
		8 WAIT_TICK():
			- Passeren the TICK semaphore.
			- When TICK occurs, all procs waiting will be unblocked.
	
	v2.1 comes with some important bug fixes and two major optimizations:
		MaxProcNum allows the OS to skip over parts of the ProcList, significantly increasing
			performance when working with only a few processes.
			
		SupportList allows the OS to quickly get information about a given process, which
			should significantly increase performance when working with many processes.
%)

/ ----------------------------------------------------Data----------------------------------------------------
(/ ------- Hardware constants -------
	/ Processor constants
	@WORD_SIZE 		 		= 16  / Word size in bits (always must be 16)
	@IO_DEVICE_COUNT 		= 32
	@OUT_REG_NUM			= 6
	@RA_REG_NUM				= 7

	@IOP_SHIFT				= 11
	@DRIVE_IOP_GROUP     	= 0
	@DRIVE_PTR_IOP_GROUP 	= 1
	@IOP_GROUP_MASK 		= 0xE000
	@IOP_GROUP_SHIFT 		= 13
	@IOP_DEVICE_MASK		= 0x1800
	@IOP_DEVICE_SHIFT		= 11
	@DRIVE_PTR_BIT 			= 13
	@MAX_UNPROT_IOP_NUM		= 23

	@HI_SHIFT 		= 8
	@HI_MASK		= 0xFF00
	@LO_SHIFT		= >HI_SHIFT
	@LO_MASK 		= 0x00FF

	@EXC_MASK 		= 0x0700
	@EXC_SHIFT 		= 8
	
	@UE_PU_SHIFT 	= 3
	@UE_CE_BIT		= 0
	
	/ EXC defined by TCS
	@EXC_TICK 	= 0
	@EXC_PAUS 	= 1
	@EXC_PVIO 	= 2
	@EXC_STOP 	= 3
	
	/ EXC defined by processor
	@EXC_CTDZ 	= 4
	@EXC_SYS 	= 5
	@EXC_PRIV 	= 6
	@EXC_OOB 	= 7


	/ Computer determined hardware constants
	@COMP_STATUS_IOP 	= 0xF000
	@RANDOM_IOP 		= >COMP_STATUS_IOP
	@COUNTER_START_IOP 	= 0xE000
	@COUNTER_STOP_IOP 	= 0xE800
	@CONFIG_IOP			= 0xF800


	/ OS determined hardware constants
	@KERNEL_PROC_FLG 	= 0x0004 			/ Exceptions enabled, user mode disabled.
	@USER_PROC_FLG 		= 0x000C			/ Exceptions enabled, user mode enabled.
	@ROOT_PROC_FLG 		= >KERNEL_PROC_FLG	/ Currently, root proc has same privs as Kernel

	@ROOT_DRIVE_IOP 	= 0x0000	/ 0th drive
)


(/ ------- OS Data Properties -------

	/ ---- PROCESSES ----
	/ Offset:		0			1				2
	/ Process = MainWord, BlockingSemAdd, BlockingSemNo
	/
	/ MainWord = [1-bit Active] [5-bit parent] [5-bit nextSib] [5-bit child]

	@MAX_PROC_COUNT 	= 32
	@NUM_PROC_WORDS		= 3		/ must be under 16
	@PROC_CxPROC_W 		= 96	/ must be MAX_PROC_COUNT x NUM_PROC_WORDS
	#ProcList 			= [~PROC_CxPROC_W]
	@SEMADD_OFFSET		= 1
	@SEMNO_OFFSET		= 2

	@PROC_ACTIVE_BIT	= 15
	@PARENT_MASK 		= 0x7C00
	@PARENT_SHIFT 		= 10
	@SIB_MASK 			= 0x03E0
	@SIB_SHIFT 			= 5
	@CHILD_MASK 		= 0x001F

	@ROOT_PROC_ID 		= 0				/ Must be 0
	@NULL_PROC_ID 		= >ROOT_PROC_ID	/ Must be ROOT_PROC_ID

	#ProcCount 			= 0		/ Number of running processes
	#MaxProcNum			= 0		/ The highest active process ID
	#CurrentProcID 		= 0		/ Current running process
	#CurrentStatePtr	= 0		/ The address of the current proc's state
	
	@MAX_DISPATCH_CYCLES = 6		/ Amount of times Dispatcher will loop ProcList before deadlock check (must be >1)
	@WAIT_TIME			 = 0xFFFF	/ Amount of cycles the OS will wait upon softblock before running dispatcher again.
									/ Right now is set to maximum, but when I/O ints are simulated, should be lowered.
	
	/ ---- SUPPORT ----
	/ Not to be confused with support structures, the support list is a list of metadata about each process.
	/ This makes many calculations within the operating system significantly faster, and is very easy to maintain.
	#SupportList	= [~MAX_PROC_COUNT]
	@SUP_ACTIVE_BIT		= 0  / Bit 0 - Proc is active
	@SUP_IS_THREAD_BIT	= 1  / Bit 1 - Proc is a thread (of another process)
	@SUP_WAIT_BIT		= 2  / Bit 2 - Proc is waiting
	@SUP_OS_WAIT_BIT	= 3  / Bit 3 - Proc is waiting on OS semaphore
	
	@INIT_SUP_WORD		= 0b0001  / Active, but nothing else.
	
	
	/ ---- STATES ----
	/ EXA and CTD are constant, PC is in the OS, and IO doesn't make sense to store, so 12 words per state
	/ Each state has the following format: RG0-7, FLG, SP, EPC, HLB
	@NUM_STATE_REGS		= 12  / Number of registers which should be stored (always 12)
	@PROC_CxSTATE_S 	= 384 / 32 max proc x 12 words per proc state = 384
	#StateList 			= [~PROC_CxSTATE_S]
	@FLG_OFFSET 		= 8
	@SP_OFFSET 			= 9
	@EPC_OFFSET 		= 10
	@HLB_OFFSET 		= 11
	
	
	/ ---- MEMORY ----
	@CHUNK_SIZE 		= 0x0400
	@NUM_CHUNKS 		= 64		/ Must be (2^16)/CHUNK_SIZE
	@BMP_WORDS 			= 4			/ Must be NUM_CHUNKS/16, and under 16
	@BMP_WORDS_2S_EXP	= 2			/ Must be sqrt(BMP_WORDS)
	#MallocBMPs 		= [~BMP_WORDS]
	
	
	/ ---- SEMAPHORES ----
	
	/ IO_DEVICE_COUNT number of 1's
	#IOMutexSems = [1, 1, 1, 1, 
					1, 1, 1, 1,
					1, 1, 1, 1,
					1, 1, 1, 1,
					1, 1, 1, 1,
					1, 1, 1, 1,
					1, 1, 1, 1,
					1, 1, 1, 1]
	
	/ All OS soft blocking semaphores must be between SEM_START and SEM_END
	#SEM_START
		/ #IOWaitSem 	= [~IO_DEVICE_COUNT ~IO_DEVICE_COUNT]	/ Doubled for seperate read and write waiting.
		#TickWaitSem 	= 0
	#SEM_END
	
	#SoftBlockCount 	= 0		/ Number of procs waiting on I/O
	
	
	/ ---- MISC ----
	#MarkInst: ALU SET RG3 RG0
	#UnmarkInst: ALU UST RG3 RG0
)


(/ ------- OS External Constants -------
	@CTD_VAL = 0x0200
	
	@TSFS_ENTRY_SIZE = 2
	
	/ Syscode name		   SysNo   Arguments
	
	@SYSCODE_LOAD_PROGRAM 	= 0  / FileNo, IsKernel? > Status Return
	@SYSCODE_MAKE_THREAD 	= 1  / PC, SP, IsKernel? > Status Return
	@SYSCODE_TERMINATE		= 2  / 
	@SYSCODE_GIVE_UP_TURN 	= 3  / 
	@SYSCODE_PASSEREN		= 4  / SemAdd > Status Return
	@SYSCODE_VERHOGEN		= 5  / SemAdd > Status Return
	@SYSCODE_IO_MUTEX		= 6  / IOP set to correct I/O
	@SYSCODE_IO_RELEASE		= 7  / IOP set to correct I/O
	@SYSCODE_WAIT_TICK		= 8  / 
	
	/ Still need to figure out how to handle these.
	/ We can get mutex, but we still need to, in some way, simulate interrupts.
	/SYSCODE_IO_WAIT_WRITE
	/SYSCODE_IO_WAIT_READ
)


(/ ------- Status & Return Codes -------
	
	/ Status codes
	@START_CODE 			= 1		  / The OS has been loaded into the computer's memory.
	@RUN_CODE 				= 2		  / The OS has successfully set up the environment and is now running processes.
	@PAUSE_CODE				= 0x1111  / The computer is currently paused due to the PAUS interrupt.
	@SHUTDOWN_CODE			= 0x2222  / If you resume the computer, it will begin shutting down.
	@END_CODE 				= 0x600D  / The OS has successfully come to a stop.
	@DEADLOCK_CODE			= 0xDEAD  / All procs are waiting on semaphores that will never be signaled.
	@BAD_START_ERROR 		= 0xFF00  / The OS has encountered a critical error attempting to set up the environment.
	@UNKNOWN_EXC_ERROR 		= 0xFF01  / The OS has encountered a critical error where EXC is not 3 bit.
	
	/ Base return codes
	@UNKNOWN_SYSCODE_ERROR 	= 0xFF02  / User proc invoked an unknown syscode.
	@PVIO_ERROR				= 0xFF03  / User proc attempted to read/write a protected device.
	
	/ Syscall return codes 
	@SYS_SUCCESSFUL			= 1		  / The operation was successful.
	@SYS_MAX_PROCS			= 0xF000  / There is no room for another proc.
	@SYS_OUT_OF_MEM			= 0xF001  / There is not enough room in memory.
	@SYS_MISSING_FILE		= 0xF002  / The file in question is missing.
	@SYS_BAD_IOP			= 0xF003  / IOP was not set correctly for this operation.
	@SYS_ATTEMPTED_OOB		= 0xF004  / The user process attempted to work with addresses out-of-bounds.
	@SYS_ATTEMPTED_PRIV		= 0xF005  / The user process attempted a privileged operation.
	@SYS_ATTEMPTED_OS		= 0xF006  / The process attempted to alter/access the OS directly.
)



/ --------------------------------------------------Base Code-------------------------------------------------



/ Initializes the OS environment
#Init  %!Fn% = {
	/ Set the status
	LDI RG0 >START_CODE; LDI FLG >COMP_STATUS_IOP; MOV IO RG0
	
	/ Start the cycle counter
	LDI FLG >COUNTER_START_IOP; MOV IO RG0
	
	/ Calculate the OS size in chunks in RG1
	LDI RG1 >OSEndPoint; LDI RG0 >CHUNK_SIZE; ALU DIV RG1 RG0
	ALI ADD RG1 2  / Add the stack chunk + 1 for remainder
	
	/ Call MarkBits(start chunk, size)
	LDI RG0 >NUM_CHUNKS; DEC RG0  / Adjust for stack (will be at end of mem)
	CAL >MarkBits
	
	/ Load the root program
	LDI FLG >ROOT_DRIVE_IOP; CAL >LoadProgLoadable
	AIN ADD OUT 1; JIF NCR >Ini.OK
		LDI RG0 >BAD_START_ERROR; JMP >StatusHalt
	#Ini.OK
	
	/ Create the root thread
	MOV RG0 OUT; LDI FLG >ROOT_PROC_FLG
	CAL >MakeChildThread
	
	/ Set the new status
	LDI RG0 >RUN_CODE; LDI FLG >COMP_STATUS_IOP; MOV IO RG0
	
	/ Make sure the dispatcher runs root first
	NUL RG0; STR RG0 RG0 >CurrentProcID
	
	/ Send control off to the dispatcher
	JMP >Dispatcher
}



/ Sets the status to RG0 and halts
#StatusHalt  %!Fn% = {
	LDI FLG >COUNTER_STOP_IOP
	MOV IO RG0
	LDI FLG >COMP_STATUS_IOP
	MOV IO RG0
	
	/ Force permanent HLT. Maybe allow reboots in the future?
	#StH.HLT
	HLT; JMP >StH.HLT
}



/ The scheduler/dispatcher runs the next process (and checks for done/deadlock/etc.)
#Dispatcher  %!Fn% = {
	/ Check if we're done
	ZRO RG0; LOD RG0 RG0 >ProcCount
	PAS RG0; JIF EQZ >Dis.Done
	
	/ If not, get the next process ID in RG0 (and MaxProcNum in RG1)
	/ We also store this ProcNum (RG6) off to check if we've done 1 cycle through the ProcList
	ZRO RG0; LOD RG0 RG0 >CurrentProcID; MOV RG6 RG0
	ZRO RG1; LOD RG1 RG1 >MaxProcNum; INC RG1
	ZRO RG5 / Number of cycles
	ALU MOD RG6 RG1 / Fix issues with CurrentProc > MaxProcID after Terminate
	#Dis.GetNext
		INC RG0; ALU MOD RG0 RG1
		
		/ Check if we've looped (too many times)
		CMP RG0 RG6; JNE >Dis.Continue
			INC RG5; CMI RG5 >MAX_DISPATCH_CYCLES; JEQ >Dis.MaybeDeadlock
		#Dis.Continue
		
		/ Then check if it's active
		LOD RG2 RG0 >SupportList; AIN SET RG2 >SUP_ACTIVE_BIT; JIF NCR >Dis.GetNext
		
		/ Now check if it's blocked
		AIN SET RG2 >SUP_WAIT_BIT; JIF CAR >Dis.GetNext
		
		/ With the new support list, simulating device interrupts here should be pretty easy.
	
	/ Store the new current process
	STR RG0 RG0 >CurrentProcID
	
	/ Find the process state and store it's address
	ALI MUL RG0 >NUM_STATE_REGS; LDI RG1 >StateList; ALU ADD RG0 RG1
	STR RG0 RG0 >CurrentStatePtr
	
	/ Load the state and RSM the process
	LOD EPC RG0 >EPC_OFFSET
	LDI EXA >ExHandler
	LDI CTD >CTD_VAL
	LOD HLB RG0 >HLB_OFFSET
	LOD FLG RG0 >FLG_OFFSET
	LOD SP RG0 >SP_OFFSET
	LOD RG7 RG0 7
	LOD RG6 RG0 6
	LOD RG5 RG0 5
	LOD RG4 RG0 4
	LOD RG3 RG0 3
	LOD RG2 RG0 2
	LOD RG1 RG0 1
	LOD RG0 RG0 0
	
	RSM
	
	
	#Dis.Done
	LDI RG0 >END_CODE
	JMP >StatusHalt
	
	#Dis.MaybeDeadlock
	/ Check if SoftBlockCount is 0 (deadlock)
	ZRO RG0; LOD RG0 RG0 >SoftBlockCount
	PAS RG0; JIF NEZ >WaitForInt
	
	/ If so, deadlock.
	LDI RG0 >DEADLOCK_CODE
	JMP >StatusHalt
}



/ The return point for all programs. Handles any exceptions that occur.
#ExHandler  %!Fn% = {
	/ Get the current proc's state address in RG0
	STR RG0 RG0 >ExH.TempRG0
	ZRO RG0; LOD RG0 RG0 >CurrentStatePtr
	
	/ Now store the old RG0 (the temp reg) into the proc state's RG0
	STR RG1 RG0 1
	ZRO RG1; LOD RG1 RG1 >ExH.TempRG0; STR RG1 RG0 0
	
	/ Finally, store off the rest of the registers
	/ Before trying to optimize this: having considered all ramifications, this is the best place to do this.
	STR RG2 RG0 2
	STR RG3 RG0 3
	STR RG4 RG0 4
	STR RG5 RG0 5
	STR RG6 RG0 6
	STR RG7 RG0 7
	STR SP RG0 >SP_OFFSET
	STR EPC RG0 >EPC_OFFSET
	STR FLG RG0 >FLG_OFFSET
	
	/ Ready the stack for the OS
	ZRO SP
	
	
	/ For in-OS waiting
	#ExH.Skip
	
	/ Get EXC in RG0
	LDI RG0 >EXC_MASK; ALU AND RG0 FLG; ALI SRB RG0 >EXC_SHIFT
	
	/ Check if the proc's CPU burst is up.
	CMI RG0 >EXC_CTDZ; JEQ >Dispatcher
	
	/ Check for Syscall
	CMI RG0 >EXC_SYS; JEQ >SysHandler
	
	/ Check if it's unrecoverable
	CMI RG0 >EXC_PRIV; JEQ >TerminateCurrent
	CMI RG0 >EXC_OOB; JEQ >TerminateCurrent
	
	/ Check if it's from the computer's user
	CMI RG0 >EXC_PAUS; JEQ >PauseMenu
	CMI RG0 >EXC_STOP; JEQ >Shutdown
	
	/ Check if it's from the computer
	CMI RG0 >EXC_TICK; JEQ >UnblockAllTick
	CMI RG0 >EXC_PVIO; JNE >ExH.UnknownEXC
		/ If the process tried to access a privileged I/O device, give it an error output and skip it.
		ZRO RG0; LOD RG0 RG0 >CurrentStatePtr
		LDI RG1 >PVIO_ERROR; STR RG1 RG0 >OUT_REG_NUM
		JMP >Dispatcher
	
	/ Else the OS has errored in some way (EXC must be one of the above), so halt.
	#ExH.UnknownEXC
	LDI RG0 >UNKNOWN_EXC_ERROR
	JMP >StatusHalt
}
#ExH.TempRG0 = 0



/ Resume the current process (if it's not waiting)
#ResumeProc  %!Fn% = {
	ZRO RG0; LOD RG0 RG0 >CurrentProcID
	LOD RG0 RG0 >SupportList; AIN SET RG0 >SUP_WAIT_BIT; JIF CAR >Dispatcher
	
	/ Restore the state
	ZRO RG0; LOD RG0 RG0 >CurrentStatePtr
	LOD SP RG0 >SP_OFFSET
	LOD FLG RG0 >FLG_OFFSET
	LOD RG7 RG0 7
	LOD RG6 RG0 6
	LOD RG5 RG0 5
	LOD RG4 RG0 4
	LOD RG3 RG0 3
	LOD RG2 RG0 2
	LOD RG1 RG0 1
	LOD RG0 RG0 0
	
	/ Resume the process
	RSM
}



/ ----------------------------------------------Memory Management---------------------------------------------



/ Loads a file at IOP into memory
/ IMPORTANT: DOES NOT MARK THE BITMAP
#LoadFile  %MemStart, FileSize w/ IOP & DrivePTR% = {
	PSH 3
	STR RG0 SP 0; STR RG1 SP 1; STR FLG SP 2

	/ Write the file to memory
	PAS RG1; JIF EQZ >LoF.Done
	#LoF.LoadLoop
		STR IO RG0 0
		INC RG0
	DCC RG1; JIF NEZ >LoF.LoadLoop
	
	/ Finally, return
	#LoF.Done
	LOD RG0 SP 0; LOD RG1 SP 1; LOD FLG SP 2
	POP 3
	RET
}



/ Returns the number of the first 0 bit, or NULL if none are found
#FindOpenMemory  %Size > FirstChunkNum|NULL% = {
	PSH 5
	STR RG0 SP 0; STR RG1 SP 1; STR RG2 SP 2; STR RG3 SP 3
	STR FLG SP 4
	
	/ Setup registers:
	/ RG0: NUM_CHUNKS / Bits left to find (+ default value in stack)
	/ RG1: Current bit
	/ RG2: Current word number
	/ RG3: Current word
	
	LDI RG0 >NUM_CHUNKS
	ZRO RG1
	ZRO RG2; LOD RG3 RG2 >MallocBMPs
	
	#FOM.OpenSearch
		/ Immediately check for wrap around (if so, we're done).
		CMP RG1 RG0; JGE >FOM.OutOfMem
		
		/ Store off the current bit for now.
		MOV RG6 RG1
		
		/ Increment bit, and if word overflow get next word.
		INC RG1; AIN SRB RG1 4; JIF CAR >FOM.SNoverflow
			INC RG2; ALI UST RG2 >BMP_WORDS_2S_EXP; LOD RG3 RG2 >MallocBMPs
		#FOM.SNoverflow
		
		/ If the bit is not open, loop.
		AFN SET RG3 RG6; JIF CAR >FOM.OpenSearch
		
		/ If not, setup RG0 for OpenCheck
		LOD RG0 SP 0
		
		#FOM.OpenCheck
			/ Decrement number of bits to find, and if zero, we're done.
			DCC RG0; JIF EQZ >FOM.Done
			
			/ Else, increment bit and check for word overflow.
			INC RG1; AIN SRB RG1 4; JIF CAR >FOM.CNoverflow
				INC RG2; ALI UST RG2 >BMP_WORDS_2S_EXP; LOD RG3 RG2 >MallocBMPs
			#FOM.CNoverflow
			
			/ If the bit is open, loop again.
			AFN SET RG3 RG1; JIF NCR >FOM.OpenCheck
		
		/ If not, setup RG0 for outer loop and goto it.
		/ NOTE: This repeats the same check (RG1 is unchanged), but it will have the same outcome so it does not matter.
		LDI RG0 >NUM_CHUNKS; JMP >FOM.OpenSearch
	
	#FOM.OutOfMem
	NUL OUT
	
	#FOM.Done
	LOD RG0 SP 0; LOD RG1 SP 1; LOD RG2 SP 2; LOD RG3 SP 3
	LOD FLG SP 4
	POP 5
	RET
}



/ Turns on bits StartChunk through StartChunk+Size-1 inclusive
#MarkBits  %StartChunk, Size% = {
	PSH 5
	STR RG0 SP 0; STR RG1 SP 1; STR RG2 SP 2; STR RG3 SP 3
	STR FLG SP 4
	
	/ Setup and jump to ModifyBits
	ZRO RG2; LOD RG2 RG2 >MarkInst
	JMP >ModifyBits
}

/ Turns off bits StartChunk through StartChunk+Size-1 inclusive
#UnmarkBits  %StartChunk, Size% = {
	PSH 5
	STR RG0 SP 0; STR RG1 SP 1; STR RG2 SP 2; STR RG3 SP 3
	STR FLG SP 4
	
	/ Setup and jump to ModifyBits
	ZRO RG2; LOD RG2 RG2 >UnmarkInst
	JMP >ModifyBits
}

/ Shell function for UnmarkBits and MarkBits DO NOT CALL
#ModifyBits {
	/ Modify code according to RG2
	STR RG2 RG2 >MoB.ModBit
	
	/ Setup the following:
	/ RG0: Current bit (already set)
	/ RG1: End bit
	/ RG2: Word number
	/ RG3: Current word
	ALU ADD RG1 RG0
	MOV RG2 RG0; ALI SRB RG2 4
	LOD RG3 RG2 >MallocBMPs
	
	#MoB.Loop
		/ If we're at the end, we're done.
		CMP RG0 RG1; JEQ >MoB.Done
		
		/ Do the operation
		#MoB.ModBit: NOP	/ ALU XXX RG3 RG0
		
		/ Go to next bit, and if no word overflow, loop again.
		INC RG0; AIN SRB RG0 4; JIF CAR >MoB.Loop
		
		/ Else, store word, and load next word.
		STR RG3 RG2 >MallocBMPs
		INC RG2; ALI UST RG2 >BMP_WORDS_2S_EXP  / Does wrap-around automatically :D
		LOD RG3 RG2 >MallocBMPs
		JMP >MoB.Loop
		
	#MoB.Done
	
	STR RG3 RG2 >MallocBMPs
	
	/ Pop and return
	LOD RG0 SP 0; LOD RG1 SP 1; LOD RG2 SP 2; LOD RG3 SP 3
	LOD FLG SP 4
	POP 5
	RET
}



/ ------------------------------------------------Process Tree------------------------------------------------



/ Creates child thread for current proc with given HLB and FLG
#MakeChildThread  %NewHLB w/ FLG > ProcNum% = {
	PSH 5
	STR RG0 SP 0; STR RG1 SP 1; STR RG2 SP 2; STR RG3 SP 3
	STR FLG SP 4
	
	/ Find inactive thread (ProcNo = RG1)
	NUL RG1
	#MCT.Search
		INC RG1
		MOV RG2 RG1; ALI MUL RG2 >NUM_PROC_WORDS; LOD RG3 RG2 >ProcList
	AIN SET RG3 >PROC_ACTIVE_BIT; JIF CAR >MCT.Search
	
	/ Activate proc and zero out semaphore fields
	ZRO RG3; ALI SET RG3 >PROC_ACTIVE_BIT; STR RG3 RG2 >ProcList
	ZRO RG3; INC RG2; STR RG3 RG2 >ProcList
	INC RG2; STR RG3 RG2 >ProcList
	
	/ Increment ProcCount
	LOD RG3 RG3 >ProcCount
	INC RG3; STR RG3 RG3 >ProcCount
	
	/ Check if this is above MaxProcNum.
	ZRO RG2; LOD RG2 RG2 >MaxProcNum
	CMP RG1 RG2; JLT >MCT.Smaller
		/ If it's not less than, it's greater than, so set MaxProcNum
		STR RG1 RG1 >MaxProcNum
	#MCT.Smaller
	
	/ Initialize its support list word
	LDI RG2 >INIT_SUP_WORD; STR RG2 RG1 >SupportList
	
	/ Get the location of its state in RG2
	MOV RG2 RG1; ALI MUL RG2 >NUM_STATE_REGS
	LDI RG3 >StateList; ALU ADD RG2 RG3
	
	/ Zero out all registers except FLG and HLB
	ZRO RG3
	STR RG3 RG2 0
	STR RG3 RG2 1
	STR RG3 RG2 2
	STR RG3 RG2 3
	STR RG3 RG2 4
	STR RG3 RG2 5
	STR RG3 RG2 6
	STR RG3 RG2 7
	STR RG3 RG2 >EPC_OFFSET
	STR RG3 RG2 >SP_OFFSET
	
	/ Set FLG and HLB
	LOD RG3 SP 4
	STR RG3 RG2 >FLG_OFFSET
	STR RG0 RG2 >HLB_OFFSET
	
	
	/ InsertChild(ThisProcNum)
	MOV RG0 RG1
	MOV OUT RG0
	
	MOV RG3 RA
	CAL >InsertChild
	MOV RA RG3
	
	/ Pop and return
	LOD RG0 SP 0; LOD RG1 SP 1; LOD RG2 SP 2; LOD RG3 SP 3
	LOD FLG SP 4
	POP 5
	RET
}



/ Adds the given process as a child to the current process
#InsertChild  %ProcNum% = {
	/ Push to stack
	PSH 5
	STR RG1 SP 0; STR RG2 SP 1; STR RG3 SP 2; STR RG4 SP 3
	STR FLG SP 4
	
	/ Quick check if it's root
	PAS RG0; JIF EQZ >InC.Done
	
	/ Get the main word of ProcNum in RG2 (and actual index in RG1)
	MOV RG1 RG0; ALI MUL RG1 >NUM_PROC_WORDS; LOD RG2 RG1 >ProcList
	
	/ Zero out the parent and sib
	LDI RG3 >SIB_MASK; ALU NOT RG3 RG3; ALU AND RG2 RG3
	LDI RG3 >PARENT_MASK; ALU NOT RG3 RG3; ALU AND RG2 RG3
	
	/ Set parent to CurrentProcID and store the main word
	ZRO RG3; LOD RG3 RG3 >CurrentProcID
	MOV RG4 RG3; ALI SLB RG4 >PARENT_SHIFT
	ALU OR RG2 RG4; STR RG2 RG1 >ProcList
	
	/ Get the current proc's main word in RG2 (and actual index in RG3) (RG1&4 are not set)
	ALI MUL RG3 >NUM_PROC_WORDS; LOD RG2 RG3 >ProcList
	
	/ Check if current proc has children
	LDI RG1 >CHILD_MASK; ALF AND RG1 RG2; JIF NEZ >InC.FindLastSib
		/ Case 1: current proc has no children
		ALU OR RG2 RG0; STR RG2 RG3 >ProcList
		JMP >InC.Done
		
	/ Case 2: current proc has children
	/ Loop through siblings to find the endpoint
	#InC.FindLastSib
		/ Actual index in RG1, main word in RG2
		ALI MUL RG1 >NUM_PROC_WORDS; LOD RG2 RG1 >ProcList
		LDI RG3 >SIB_MASK; ALF AND RG3 RG2; JIF EQZ >InC.FoundLast
		ALI SRB RG3 >SIB_SHIFT; MOV RG1 RG3; JMP >InC.FindLastSib
	#InC.FoundLast
	
	/ Set proc as sibling of last sib and we're done
	MOV RG3 RG0; ALI SLB RG3 >SIB_SHIFT
	ALU OR RG2 RG3; STR RG2 RG1 >ProcList
	#InC.Done
	
	/ Pop and return
	LOD RG1 SP 0; LOD RG2 SP 1; LOD RG3 SP 2; LOD RG4 SP 3
	LOD FLG SP 4
	POP 5
	RET
}



/ (ProcNum) removes the given process as a child from the process tree
/ Does not alter the proc's main word
#RemoveChild  %ProcNum% = {
	PSH 5
	STR RG2 SP 0; STR RG3 SP 1; STR RG4 SP 2; STR RG5 SP 3
	STR FLG SP 4

	/ Case 1 - Proc is root, nothing to do
	PAS RG0; JIF EQZ >ReC.Done
	
	/ Get the process word in RG5
	MOV RG5 RG0; ALI MUL RG5 >NUM_PROC_WORDS; LOD RG5 RG5 >ProcList
	
	/ Get the parent's main word in RG3 (and actual index in RG2)
	LDI RG2 >PARENT_MASK; ALU AND RG2 RG5; ALI SRB RG2 >PARENT_SHIFT
	ALI MUL RG2 >NUM_PROC_WORDS; LOD RG3 RG2 >ProcList
	
	/ Check if the process is the first child
	LDI RG4 >CHILD_MASK; ALU AND RG4 RG3
	CMP RG4 RG0; JNE >ReC.IsSibling
		/ Case 2 - Proc is the first child, set parent's child id to proc's sib id
		LDI RG4 >CHILD_MASK; ALU NOT RG4 RG4; ALU AND RG3 RG4
		LDI RG4 >SIB_MASK; ALU AND RG4 RG5; ALI SRB RG4 >SIB_SHIFT  / Get child in RG4
		ALU OR RG3 RG4; STR RG3 RG2 >ProcList
		JMP >ReC.Done
		
	#ReC.IsSibling
		/ Case 3 - Proc is a sibling, "bridge" over the process
		/ What we need to do this: the previous sibling's main word + relative address
		
		#ReC.SibLoop
			/ Get the main word in RG2 
			ALI MUL RG4 >NUM_PROC_WORDS; LOD RG2 RG4 >ProcList
		
			/ Get the sibling's ProcNo (RG3)
			LDI RG3 >SIB_MASK; ALU AND RG3 RG2; ALI SRB RG3 >SIB_SHIFT
			
			/ If this is our ProcNum (RG0), then break
			CMP RG3 RG0; JEQ >ReC.FoundSib
			
			/ Else, ready RG4 to loop again
			MOV RG4 RG3; JMP >ReC.SibLoop
			
		#ReC.FoundSib
		
		/ Found the sibling, bridge over the process.
		/ RG4 is the relative address, RG2 is the sibling's main word
		
		/ Get the current proc's sibling field (unshifted, RG5)
		LDI RG3 >SIB_MASK; ALU AND RG5 RG3
		
		/ Remove the previous sibling's sibling field and update it
		ALU NOT RG3 RG3; ALU AND RG2 RG3
		ALU OR RG2 RG5; STR RG2 RG4 >ProcList
	
	#ReC.Done
	LOD RG2 SP 0; LOD RG3 SP 1; LOD RG4 SP 2; LOD RG5 SP 3
	LOD FLG SP 4
	POP 5
	RET
}



/ -----------------------------------------------Core Functions-----------------------------------------------



/ For now does not do much, but in the future there will be extra features associated with this.
/ When the user triggers the PAUS interrupt, this subroutine is called.
#PauseMenu  %!Fn% = {
	LDI FLG >COMP_STATUS_IOP; LDI IO >PAUSE_CODE
	HLT
	JMP >ResumeProc
}



/ Shuts the computer down.
/ Perhaps this should give procs an opportunity to stop themselves in the future.
/ Maybe start by blocking all new threading and loading attempts?
/ AND the above only happens the first time shutdown is called. The second time it just terminates root.
#Shutdown  %!Fn% = {
	/ For now, just pauses and terminates root, terminating all other procs.
	LDI FLG >COMP_STATUS_IOP; LDI IO >SHUTDOWN_CODE
	HLT
	
	ZRO RG0; CAL >Terminate
	JMP >Dispatcher
}



/ When the TICK interrupt occurs, this function is called.
#UnblockAllTick  %!Fn% = {
	/ Do UnblockAll(TickWaitSem)
	LDI RG0 >TickWaitSem
	CAL >UnblockAll
	
	/ Process interrupt
	LDI FLG >CONFIG_IOP; ZRO IO
	
	/ Resume proc
	JMP >ResumeProc
}



/ Deactivates, deallocates, and un-childs ProcNum and all its children.
/ Now handles semaphores and selective deallocation (if thread, don't dealloc), along with MaxProcNum
/ Shell function for RecursiveTerm
#Terminate  %ProcNum% = {
	PSH 7
	STR RG1 SP 0; STR RG2 SP 1; STR RG3 SP 2; STR RG4 SP 3; STR RG5 SP 4
	STR RA SP 5; STR FLG SP 6
	
	/ First, call RecursiveTerm
	ZRO RG1; CAL >RecursiveTerm
	
	/ Now we have to (probably) update MaxProcNum
	/ Get MaxProcNum
	ZRO RG0; LOD RG0 RG0 >MaxProcNum
	#Ter.Loop
		/ Make sure it's not root
		PAS RG0; JIF EQZ >Ter.Done
		
		/ Check the support word to see if its active, and if so this is MaxProcNum
		LOD RG1 RG0 >SupportList; AIN SET RG1 >SUP_ACTIVE_BIT; JIF CAR >Ter.Done
		
		/ Decrement and loop
		DEC RG0; JMP >Ter.Loop
	#Ter.Done
	
	/ Whatever is in RG0 is the correct MaxProcNum
	STR RG0 RG0 >MaxProcNum
	
	LOD RG1 SP 0; LOD RG2 SP 1; LOD RG3 SP 2; LOD RG4 SP 3; LOD RG5 SP 4
	LOD RA SP 5; LOD FLG SP 6
	POP 7
	RET
}

/ Always call with Recursed?(RG1) = 0.
/ RG0 is the ProcNum
#RecursiveTerm  {
	PSH 3; STR RG0 SP 0; STR RA SP 1
	
	/ Push the proc's MainWord to the stack (using RG2)
	MOV RG2 RG0; ALI MUL RG2 >NUM_PROC_WORDS; LOD RG2 RG2 >ProcList
	STR RG2 SP 2
	
	/ If recursing, try to call RecursiveTerm on sibling
	PAS RG1; JIF EQZ >ReT.NotRecurse
		/ Get the sibling proc num. (MainWord in RG2 from above)
		LDI RG3 >SIB_MASK; ALF AND RG2 RG3
		
		/ If there's no sibling, we're done.
		JIF EQZ >ReT.Recurse
			/ Else, call RecursiveTerm on it recursively
			ALI SRB RG2 >SIB_SHIFT; MOV RG0 RG2
			LDI RA >ReT.Recurse; JMP >RecursiveTerm
			
	#ReT.NotRecurse
		/ If not recursing, call RemoveChild
		CAL >RemoveChild
		
	#ReT.Recurse
	LOD RG0 SP 0
	/ Past this point, argument 1 (RG1) is no longer needed.
	
	/ If the process is waiting on a SemAdd, we need to:
	/ A) If the semaphore is in the OS, decrement softblockcount.
	/ B) Increment the semaphore.
	/ C) Increment the SemNo of all other procs where:
	/	1. Its SemAdd is the same.
	/	2. Its SemNo is LOWER (meaning it is behind this proc on the wait list).
	/ We do not wake up any procs because all procs under consideration are on a wait list.
	
	/ Get the support word in RG3, and check if the proc is blocked
	LOD RG3 RG0 >SupportList; AIN SET RG3 >SUP_WAIT_BIT; JIF NCR >ReT.VSkip
		/ Getting the SemAdd in RG2
		MOV RG1 RG0; ALI MUL RG1 >NUM_PROC_WORDS; INC RG1
		LOD RG2 RG1 >ProcList
		
		/ Last usage of support word to check if blocked on OS semaphore
		AIN SET RG3 >SUP_OS_WAIT_BIT; JIF NCR >ReT.NotOSSem
			/ If the semaphore is in the OS, decrement softblockcount
			ZRO RG3; LOD RG3 RG3 >SoftBlockCount
			DEC RG3; STR RG3 RG3 >SoftBlockCount
		#ReT.NotOSSem
		
		/ Getting the SemNo in RG1
		MOV RG4 RG1; INC RG1; LOD RG1 RG1 >ProcList
		
		/ Remove the SemAdd and SemNo from the process
		ZRO RG3; STR RG3 RG4 >ProcList
		INC RG4; STR RG3 RG4 >ProcList
		
		/ Incrementing [SemAdd]
		LOD RG3 RG2 0; INC RG3; STR RG3 RG2 0

		/ Now begin looping through each proc (RG3) in ProcList
		NUL RG3; ZRO RG0; LOD RG0 RG0 >MaxProcNum; INC RG0
		#ReT.VLoop
			INC RG3; CMP RG3 RG0; JEQ >ReT.VSkip
			
			/ Check if the SemAdd (RG5) is equal (and if not, go to the next proc)
			MOV RG4 RG3; ALI MUL RG4 >NUM_PROC_WORDS; INC RG4
			LOD RG5 RG4 >ProcList
			CMP RG5 RG2; JNE >ReT.VLoop
			
			/ Now check if its SemNo (RG5) is lower (and if not, go to next proc)
			INC RG4; LOD RG5 RG4 >ProcList
			CMP RG5 RG1; JGE >ReT.VLoop
			
			/ Finally, increment the SemNo if it passed all the other checks, and loop.
			INC RG5; STR RG5 RG4 >ProcList
			JMP >ReT.VLoop
	#ReT.VSkip
	
	/ End of semaphore code
	
	/ We still need to:
	/ A) Deallocate the proc's memory only if it's not a thread.
	/ B) Recurse downwards in the tree.
	/ C) Formally delete the process (deactivate proc, decrement ProcCount, clear support word).
	
	/ Check if this is a child thread (and skip dealloc if it is)
	LOD RG0 SP 0
	LOD RG1 RG0 >SupportList; AIN SET RG1 >SUP_IS_THREAD_BIT; JIF CAR >ReT.SkipDealloc
	
	/ Get current proc's HLB(RG2)
	MOV RG2 RG0; ALI MUL RG2 >NUM_STATE_REGS; ALI ADD RG2 >HLB_OFFSET
	LOD RG2 RG2 >StateList
	
	/ Go straight to deallocating if this is root
	PAS RG0; JIF EQZ >ReT.Dealloc
		
	#ReT.Dealloc
		/ Call UnmarkBits(Start, Size)
		MOV RG1 RG2; LDI RG3 >CHUNK_SIZE; ALU DIV RG1 RG3
		LDI RG0 >LO_MASK; ALU AND RG0 RG2; ALI SLB RG0 >LO_SHIFT; ALU DIV RG0 RG3
		CAL >UnmarkBits
	#ReT.SkipDealloc
	
	/ Call RecursiveTerm on child procs (if they exist)
	LOD RG2 SP 2
	LDI RG3 >CHILD_MASK; ALF AND RG2 RG3
	JIF EQZ >ReT.NoChilds
		MOV RG0 RG2; NUL RG1; CAL >RecursiveTerm
		LOD RG0 SP 0
	#ReT.NoChilds
	
	/ Deactivate the proc
	MOV RG2 RG0; ALI MUL RG2 >NUM_PROC_WORDS
	ZRO RG1; STR RG1 RG2 >ProcList
	
	/ Decrement ProcCount
	ZRO RG1; LOD RG1 RG1 >ProcCount; DEC RG1; STR RG1 RG1 >ProcCount
	
	/ Clear its support word
	ZRO RG1; STR RG1 RG0 >SupportList
	
	/ Return
	LOD RG0 SP 0; LOD RA SP 1; POP 3
	RET
}



/ The Passeren (Wait) semaphore operation.
/ Must be a function so OS can call it on procs.
#Passeren  %Address, ProcNum > ProcMustWait?% = {
	PSH 3
	STR RG2 SP 0; STR RG3 SP 1; STR FLG SP 2

	/ Decrement semaphore
	LOD RG2 RG0 0; DEC RG2; STR RG2 RG0 0
	
	/ If still positive, skip over the rest of Passeren
	PAS RG2; JIF GEZ >Pas.Skip
		/ Else, set SemAdd
		MOV RG3 RG1; ALI MUL RG3 >NUM_PROC_WORDS; INC RG3
		STR RG0 RG3 >ProcList
		/ Set SemNo
		INC RG3; STR RG2 RG3 >ProcList
		
		/ Add WAIT to the support word.
		LOD RG3 RG1 >SupportList; ALI SET RG3 >SUP_WAIT_BIT
		
		/ Check if SemAdd is an OS semaphore.
		LDI RG2 >SEM_START; CMP RG0 RG2; JLT >Pas.NotOSSem
		LDI RG2 >SEM_END; CMP RG0 RG2; JGE >Pas.NotOSSem
			/ If so, increment SoftBlockCount
			ZRO RG2; LOD RG2 RG2 >SoftBlockCount
			INC RG2; STR RG2 RG2 >SoftBlockCount
			
			/ And add OS_WAIT to the support word
			ALI SET RG3 >SUP_OS_WAIT_BIT
		#Pas.NotOSSem
		
	/ Update the support word
	STR RG3 RG1 >SupportList
		
	/ And return 1 (proc must wait)
	LDI OUT 1 JMP >Pas.Done
		
	#Pas.Skip
	/ Return 0 (proc doesn't have to wait)
	ZRO OUT
	
	#Pas.Done
	LOD RG2 SP 0; LOD RG3 SP 1; LOD FLG SP 2
	POP 3
	RET
}



/ The Verhogen (Signal) semaphore operation.
/ Must be a function so OS can call it on procs.
#Verhogen  %Address% = {
	PSH 5
	STR RG0 SP 0; STR RG1 SP 1; STR RG2 SP 2; STR RG3 SP 3; STR RG4 SP 4
	STR FLG SP 5
	
	/ Increment the semaphore
	LOD RG1 RG0 0; INC RG1; STR RG1 RG0 0
	
	/ Now start looping through each process (RG1 = ProcNum)
	NUL RG1; ZRO RG2; LOD RG2 RG2 >MaxProcNum; INC RG2
	#Ver.Loop
		INC RG1; CMP RG1 RG2; JEQ >Ver.Done
		
		/ Get the SemAdd (and loop again if it's not the same)
		MOV RG3 RG1; ALI MUL RG3 >NUM_PROC_WORDS; INC RG3
		LOD RG4 RG3 >ProcList; CMP RG4 RG0; JNE >Ver.Loop
		
		/ Increment SemNo
		INC RG3; LOD RG4 RG3 >ProcList
		INC RG4; STR RG4 RG3 >ProcList
		
		/ Check if the process is off its wait list (SemNo is >=0)
		PAS RG4; JIF LTZ >Ver.Loop
		
		/ If so, remove SemAdd and SemNo
		ZRO RG4; STR RG4 RG3 >ProcList
		DEC RG3; STR RG4 RG3 >ProcList
		
		/ Remove WAIT from the support word
		LOD RG3 RG1 >SupportList; ALI UST RG3 >SUP_WAIT_BIT
		
		/ Check if semaphore is in OS
		LDI RG4 >SEM_START; CMP RG0 RG4; JLT >Ver.NotInOS
		LDI RG4 >SEM_END; CMP RG0 RG4; JGE >Ver.NotInOS
		
			/ If so, decrement SoftBlockCount
			ZRO RG4; LOD RG4 RG4 >SoftBlockCount
			DEC RG4; STR RG4 RG4 >SoftBlockCount
			
			/ And remove OS_WAIT from the support word
			ALI UST RG3 >SUP_OS_WAIT_BIT
		#Ver.NotInOS
		
		/ Update the support word.
		STR RG3 RG1 >SupportList
		
		/ Loop
		JMP >Ver.Loop
	#Ver.Done
	
	/ When done, return
	LOD RG0 SP 0; LOD RG1 SP 1; LOD RG2 SP 2; LOD RG3 SP 3; LOD RG4 SP 4
	LOD FLG SP 5
	POP 5
	RET
}



/ Unblocks all processes associated with the given semaphore.
#UnblockAll  %SemAdd% = {
	PSH 7
	STR RG1 SP 0; STR RG2 SP 1; STR RG3 SP 2; STR RG4 SP 3; STR RG5 SP 4
	STR RG6 SP 5; STR FLG SP 6
	
	/ Loop through all procs (RG1 = ProcNum, RG2 = Count)
	NUL RG1; ZRO RG2
	#UnA.Loop
		INC RG1; LDI RG3 >MAX_PROC_COUNT
		CMP RG1 RG3; JEQ >UnA.Done
	
		/ Check if matching SemAdd (if not, loop)
		MOV RG3 RG1; ALI MUL RG3 >NUM_PROC_WORDS; INC RG3
		LOD RG4 RG3 >ProcList; CMP RG4 RG0; JNE >UnA.Loop
		
		/ If matching, unset WAIT in the support word.
		LOD RG6 RG1 >SupportList; ALI UST RG6 >SUP_WAIT_BIT
		
		/ Then check if SemAdd is in the OS semaphores.
		LDI RG5 >SEM_START; CMP RG4 RG5; JLT >UnA.NotOS
		LDI RG5 >SEM_END; CMP RG4 RG5; JGE >UnA.NotOS
			/ If in the OS, decrement SoftBlockCount
			ZRO RG5; LOD RG5 RG5 >SoftBlockCount
			DEC RG5; STR RG5 RG5 >SoftBlockCount
			
			/ And unset OS_WAIT in the support word.
			ALI UST RG6 >SUP_OS_WAIT_BIT
		#UnA.NotOS
		
		/ Update the support word
		STR RG6 RG1 >SupportList
	
		/ Set proc's SemAdd & SemNo to 0
		ZRO RG4; STR RG4 RG3 >ProcList
		INC RG3; STR RG4 RG3 >ProcList
		
		/ Count++ and loop
		INC RG2; JMP >UnA.Loop
	#UnA.Done
	
	/ Do [SemAdd] += count and return.
	LOD RG1 RG0 0; ALU ADD RG1 RG2; STR RG1 RG0 0
	
	LOD RG1 SP 0; LOD RG2 SP 1; LOD RG3 SP 2; LOD RG4 SP 3; LOD RG5 SP 4
	LOD RG6 SP 5; LOD FLG SP 6
	POP 7
	RET
}



/ Loads the program file at IOP into memory. Returns HLB, NULL if no space, or 0 no file.
/ Does not create the thread for said program, but does basically everything else.
/ Modifies RG0-5, and FLG
#LoadProgramTSFS  %FileNum w/ IOP > NewHLB|NULL|0% = {

	PSH 2; STR RA SP 0
	
	
	% Unused drive format check code:
	
	/ First, check if it's TSFS (These checks really don't take much time thanks to how IO is handled)
	
	/ Quick "parity check"
	MOV RG2 IO; AIN MOD RG2 >TSFS_ENTRY_SIZE; JIF NEZ >LPT.TSFSError
	
	/ Longer, "zero check"
	#LPT.ZLoop
		/ Get the pointer to the end of the drive.
		ALI SUB RG2 >TSFS_ENTRY_SIZE
		ALI SET FLG >DRIVE_PTR_BIT; MOV IO RG2; ALI UST FLG >DRIVE_PTR_BIT
		MOV RG1 IO; PAS RG1; JIF EQZ >LPT.ZLoop
	/ Got the address for end of memory.
	MOV RG2 RG1
	
	/ Just make sure this actually is the pointer.
	PAS IO; JIF NEZ >LPT.TSFSError
	
	/ Now check to see if it's (probably) the end of memory.
	ALI SET FLG >DRIVE_PTR_BIT; MOV IO RG2; ALI UST FLG >DRIVE_PTR_BIT
	PAS IO; JIF NEZ >LPT.TSFSError
	%
	
	/ Check if the given file number actually exists (within the index)
	ALI MUL RG0 >TSFS_ENTRY_SIZE
	ZRO RG1; ALI SET FLG >DRIVE_PTR_BIT; MOV IO RG1; ALI UST FLG >DRIVE_PTR_BIT
	MOV RG1 IO; CMP RG0 RG1; JGE >LPT.FileError
	
	/ Check if the file is empty
	ALI SET FLG >DRIVE_PTR_BIT; MOV IO RG0; ALI UST FLG >DRIVE_PTR_BIT
	MOV RG0 IO; PAS IO; JIF EQZ >LPT.FileError
	
	/ Tell LoadProgLoadable where to load this file.
	STR RG0 SP 1; JMP >LPL.LPTSkip
	
	
	#LPT.FileError
	ZRO OUT; POP 2; RET
}

/ LPT, but for .tload drives
#LoadProgLoadable  %w/ IOP > NewHLB|NULL% = {

	PSH 2; STR RA SP 0; ZRO RG0; STR RG0 SP 1
	#LPL.LPTSkip  / LPL has already done the above 4 instructions
	
	/ Calculate the size of the program in RG0 (in chunks)
	ALI SET FLG >DRIVE_PTR_BIT; MOV IO RG0; ALI UST FLG >DRIVE_PTR_BIT
	MOV RG0 IO
	LDI RG1 >CHUNK_SIZE; ALU DIV RG0 RG1; ALI ADD RG0 2
	
	/ Check memory to see where it will fit
	CAL >FindOpenMemory  / = FirstChunk
	AIN ADD OUT 1; JIF CAR >LPL.Error
	
	/ Calculate HLB then do MarkBits(FirstChunk, Size)
	MOV RG1 RG0; MOV RG0 OUT
	
	LDI RG2 >CHUNK_SIZE; ALU MUL OUT RG2; ALI SRB OUT >LO_SHIFT
	MOV RG3 RG1; ALU MUL RG3 RG2; ALU OR OUT RG3
	CAL >MarkBits

	/ Load program into memory using LoadFile(CHUNK_SIZE * FirstChunk, Size)
	LOD RG1 SP 1
	LDI RG2 >CHUNK_SIZE; ALU MUL RG0 RG2
	ALI SET FLG >DRIVE_PTR_BIT; MOV IO RG1; ALI UST FLG >DRIVE_PTR_BIT; MOV RG1 IO
	
	LOD RA SP 0; POP 2; JMP >LoadFile	/ This is the last function call, so return to RA
	
	/ Unless there was an error, then return NULL
	#LPL.Error
	NUL OUT; LOD RA SP 0; POP 2; RET
}



/ ----------------------------------------------Helper Functions----------------------------------------------



/ Won't return, and will instead goto SRH.UserPriv, if the proc is accessing protected devices and is user.
#CheckIOPAccess  %None > IOP | no return% = {
	PSH 3
	STR RG0 SP 0; STR RG1 SP 1; STR FLG SP 2

	/ Get the proc's FLG (in RG0)
	ZRO RG0; LOD RG0 RG0 >CurrentStatePtr; LOD RG0 RG0 >FLG_OFFSET
	
	/ Check if the proc is kernel (meaning we can skip checks)
	AIN SET RG0 >UE_PU_SHIFT; JIF NCR >CIA.IsKernel
		/ If it's user, first make sure it's not accessing DevNo 0
		LDI RG1 >IOP_DEVICE_MASK
		AFN AND RG0 RG1; JIF EQZ >SRH.UserPriv
		
		/ Now make sure it's not accessing protected device groups
		ALI SRB RG0 >IOP_SHIFT
		LDI RG1 >MAX_UNPROT_IOP_NUM; CMP RG1 RG0; JLT >SRH.UserPriv
		JMP >CIA.Done
		
	#CIA.IsKernel
		/ If kernel, just get IOP num in RG0
		ALI SRB RG0 >IOP_SHIFT
		
	#CIA.Done
	
	/ Now return the IOP number
	MOV OUT RG0
	
	LOD RG0 SP 0; LOD RG1 SP 1; LOD FLG SP 2
	POP 3
	RET
}



/ Checks the given relative address from the current process to see if it is OOB or in the OS.
#CheckCurProcAddress  %RelAddr > Addr | no return% = {
	PSH 4
	STR RG2 SP 0; STR RG3 SP 1; STR RG4 SP 2
	STR FLG SP 3
	
	/ Get FLG (RG3) and HLB (RG2)
	ZRO RG2; LOD RG2 RG2 >CurrentStatePtr
	LOD RG3 RG2 >FLG_OFFSET
	LOD RG2 RG2 >HLB_OFFSET
	
	/ Check for Kernel
	AIN SET RG3 >UE_PU_SHIFT; JIF NCR >CPA.IsKernel
		/ If not kernel, check for OOB using HI (RG3) (This is the only way they can OOB)
		MOV RG3 RG2; LDI RG4 >HI_MASK; ALU AND RG3 RG4
		MOV RG4 RG0
		ALI SRB RG4 1; ALI SRB RG3 1
		CMP RG4 RG3; JGE >SRH.UserOOB
		
		/ Finally, get the real address in OUT and return
		ALI SLB RG2 >LO_SHIFT; ALU ADD RG2 RG0; MOV OUT RG2
		JMP >CPA.Done
		
	#CPA.IsKernel
		/ If Kernel, get the real address in OUT
		ALI SLB RG2 >LO_SHIFT; ALU ADD RG2 RG0; MOV OUT RG2
		
		/ Check for OSMod
		ALI SRB RG2 1
		LDI RG3 >OSEndPoint; INC RG3; ALI SRB RG3 1  / INC here just to make sure there are no shift issues.
		CMP RG2 RG4; JLT >SRH.OSMod
		
		/ If not, return.
	#CPA.Done
	
	LOD RG2 SP 0; LOD RG3 SP 1; LOD RG4 SP 2
	LOD FLG SP 3
	POP 4
	RET
}



/ Calls terminate on the current process then returns to the dispatcher
#TerminateCurrent  %!Fn% = {
	ZRO RG0; LOD RG0 RG0 >CurrentProcID
	LDI RA >Dispatcher; JMP >Terminate
}



/ Syscall return codes handler.
/ Meant to be treated as a collection of mini subroutines.
/ IMPORTANT: YOU DO NOT NEED TO WORRY ABOUT MISALIGNED SP WHEN JUMPING HERE!
#SysReturnHandler  %!Fn% = {
	/ The operation was successful. Resume the process
	#SRH.Success
	LDI RG0 >SYS_SUCCESSFUL
	ZRO RG1; LOD RG1 RG1 >CurrentStatePtr
	STR RG0 RG1 >OUT_REG_NUM
	JMP >ResumeProc
	
	/ Sometimes we want to skip the process, even if the operation was successful.
	#SRH.SuccessSkip
	LDI RG0 >SYS_SUCCESSFUL; JMP >SRH.FinSkip
	
	/ For all errors we skip the process.
	
	/ There is no room for another proc.
	#SRH.MaxProcs
	LDI RG0 >SYS_MAX_PROCS; JMP >SRH.FinSkip
	
	/ There is not enough room in memory.
	#SRH.OutOfMem
	LDI RG0 >SYS_OUT_OF_MEM; JMP >SRH.FinSkip
	
	/ The file in question is missing.
	#SRH.MissingFile
	LDI RG0 >SYS_MISSING_FILE; JMP >SRH.FinSkip
	
	/ IOP was not set correctly for this operation.
	#SRH.IOPError
	LDI RG0 >SYS_BAD_IOP; JMP >SRH.FinSkip
	
	/ The user process attempted to work with addresses out-of-bounds.
	#SRH.UserOOB
	LDI RG0 >SYS_ATTEMPTED_OOB; JMP >SRH.FinSkip
	
	/ The user process attempted a privileged operation.
	#SRH.UserPriv
	LDI RG0 >SYS_ATTEMPTED_PRIV; JMP >SRH.FinSkip
	
	/ The process attempted to alter/access the OS directly.
	#SRH.OSMod
	LDI RG0 >SYS_ATTEMPTED_OS; JMP >SRH.FinSkip
	
	/ Write the error code in RG0 and skip the process
	#SRH.FinSkip
	ZRO RG1; LOD RG1 RG1 >CurrentStatePtr
	STR RG0 RG1 >OUT_REG_NUM
	JMP >Dispatcher
}



/ Waits for an interrupt.
/ If the specified time passes (WAIT_TIME), then run dispatcher again, else jump to ExH.Skip to handle it.
#WaitForInt  %!Fn% = {	
	/ The only possible interrupts are TICK, PAUS, STOP, and CTDZ.
	
	/ Store off CTD.
	PSH 1; STR CTD SP 0
	
	/ Setup registers for waiting.
	LDI EXA >WFI.Done; LDI CTD >WAIT_TIME; ALI SET FLG >UE_CE_BIT
	
	/ Wait...
	#WFI.Wait: JMP >WFI.Wait
	
	/ Now reset registers.
	#WFI.Done
	ALI UST FLG >UE_CE_BIT; LDI EXA >ExHandler
	
	/ Check if it was CTDZ
	PAS CTD; JIF EQZ >Dispatcher
	
	/ Else, let the exception handler handle it
	LOD CTD SP 0; POP 1
	JMP >ExH.Skip
}



/ --------------------------------------------------Syscalls--------------------------------------------------



/ Syscall handler.
#SysHandler  %!Fn% = {
	/ Get the proc's RG1, RG2, RG3, & RG0 in RG0, RG1, RG2, & RG3 respectively (for convenience)
	ZRO RG4; LOD RG4 RG4 >CurrentStatePtr
	LOD RG0 RG4 1; LOD RG1 RG4 2; LOD RG2 RG4 3; LOD RG3 RG4 0
	
	/ Check if it's GiveUpTurn
	CMI RG3 >SYSCODE_GIVE_UP_TURN; JEQ >Dispatcher
	
	/ Check if it's the load syscall
	CMI RG3 >SYSCODE_LOAD_PROGRAM; JEQ >SysLoadProg
	
	/ Check if it's the make thread syscall
	CMI RG3 >SYSCODE_MAKE_THREAD; JEQ >SysSpawnThread
	
	/ Check if it's the terminate syscall
	CMI RG3 >SYSCODE_TERMINATE; JEQ >TerminateCurrent
	
	/ Check if it's Verhogen
	CMI RG3 >SYSCODE_VERHOGEN; JEQ >SysVerhogen
	
	/ Check if it's Passeren
	CMI RG3 >SYSCODE_PASSEREN; JEQ >SysPasseren
	
	/ Check if it's I/O mutex
	CMI RG3 >SYSCODE_IO_MUTEX; JEQ >SysIOMutex
	
	/ Check if it's I/O release
	CMI RG3 >SYSCODE_IO_RELEASE; JEQ >SysIORelease
	
	/ Check if it's wait for tick
	CMI RG3 >SYSCODE_WAIT_TICK; JEQ >SysWaitTick
	
	/ Else, return SYSCODE_ERROR
	LDI RG0 >UNKNOWN_SYSCODE_ERROR; STR RG0 RG4 6; JMP >ResumeProc
}



/ Spawns a thread given the PC & SP, and whether the thread should be kernel.
/ Note: We are jumping to SysReturnHandler no matter what, so no need to worry about SP.
#SysSpawnThread  %PC, SP, IsKernel? > !Fn% = {
	/ Store the arguments for later use.
	PSH 3; STR RG0 SP 0; STR RG1 SP 1; STR RG2 SP 2
	
	/ Make sure that there is room for the thread
	ZRO RG3; LOD RG3 RG3 >ProcCount
	LDI RG4 >MAX_PROC_COUNT; CMP RG3 RG4; JEQ >SRH.MaxProcs
	
	/ If current proc is user, check to make sure PC, SP, and IsKernel are acceptable.
	/ Use the new CheckCurProcAddress
	
	/ First, check IsKernel
	ZRO RG3; LOD RG3 RG3 >CurrentStatePtr; LOD RG3 RG3 >FLG_OFFSET
	AIN SET RG3 >UE_PU_SHIFT; JIF NCR >SST.Kernel
		/ If not kernel, make sure IsKernel is 0
		PAS RG2; JIF NEZ >SRH.UserPriv
	#SST.Kernel
	
	/ Now check PC and SP (by swapping RG0 and RG1)
	CAL >CheckCurProcAddress
	MOV RG2 RG1; MOV RG1 RG0; MOV RG0 RG2
	CAL >CheckCurProcAddress
	
	/ Check if this should be a user or kernel proc.
	LOD RG2 SP 2; PAS RG2; JIF EQZ >SST.SpawnU
		/ Spawning a kernel process.
		LDI FLG >KERNEL_PROC_FLG; JMP >SST.Skip
	#SST.SpawnU
		/ Spawning a user process.
		LDI FLG >USER_PROC_FLG
	#SST.Skip
	
	/ Call MakeChildThread with HLB and FLG, get ProcNum from it.
	ZRO RG0; LOD RG0 RG0 >CurrentStatePtr; LOD RG0 RG0 >HLB_OFFSET
	CAL >MakeChildThread
	
	/ Use ProcNum to get the pointer to its state.
	LDI RG0 >NUM_STATE_REGS; ALU MUL RG0 OUT
	LDI RG1 >StateList; ALU ADD RG0 RG1
	
	/ Now set EPC and SP.
	LOD RG1 SP 0; STR RG1 RG0 >EPC_OFFSET
	LOD RG1 SP 1; STR RG1 RG0 >SP_OFFSET
	
	/ Finally, set its IS_THREAD support bit
	LOD RG1 OUT >SupportList; ALI SET RG1 >SUP_IS_THREAD_BIT; STR RG1 OUT >SupportList
	
	/ Resume current process.
	JMP >SRH.Success
}



/ Loads the program, makes it a child thread, then resumes the current process, setting OUT accordingly.
/ Note: We are jumping to SysReturnHandler no matter what, so no need to worry about SP.
/ RG1 is the boolean for child proc is Kernel, and RG0 is the file number
#SysLoadProg  %FileNumber, IsKernel? > !Fn% = {
	
	PSH 1; STR RG1 SP 0
	
	/ Before doing anything, make sure we can actually spawn a process
	ZRO RG1; LOD RG1 RG1 >ProcCount; LDI RG2 >MAX_PROC_COUNT
	CMP RG1 RG2; JGE >SRH.MaxProcs
	
	/ Get FLG and make sure pUser is set to 0
	ZRO RG1; LOD RG1 RG1 >CurrentStatePtr; LOD RG2 RG1 >FLG_OFFSET
	AIN SET RG2 >UE_PU_SHIFT; JIF CAR >SRH.UserPriv
	
	/ Check if FLG is configured properly
	LDI RG1 >IOP_GROUP_MASK; ALU AND RG1 RG2; ALI SRB RG1 >IOP_GROUP_SHIFT
	CMI RG1 >DRIVE_IOP_GROUP; JNE >SRH.IOPError
	
	/ Check which load function we're calling, set FLG then jump
	MOV FLG RG2; LDI RA >SLP.Ret
	AIN ADD RG0 1; JIF EQZ >LoadProgLoadable
		JMP >LoadProgramTSFS
	#SLP.Ret
	
	/ Check for loading errors
	AIN ADD OUT 1; JIF CAR >SRH.OutOfMem
	AIN SUB OUT 1; JIF LTZ >SRH.MissingFile
	
	/ Figure out what privilege level to spawn child proc at.
	LOD RG0 SP 0; PAS RG0; JIF EQZ >SLP.ChildUser
		LDI FLG >KERNEL_PROC_FLG; JMP >SLP.ChildUSkip
	#SLP.ChildUser
		LDI FLG >USER_PROC_FLG
	#SLP.ChildUSkip
	
	/ Now spawn the thread
	MOV RG0 OUT; LDI RA >SRH.Success; JMP >MakeChildThread
}



/ The Passeren syscall. Does all the checks to make sure syscall is valid.
#SysPasseren  %RelSemAdd > !Fn% = {
	
	/ Make sure the given address is OK to Passeren.
	CAL >CheckCurProcAddress
	
	/ Now call Passeren with the given address.
	MOV RG0 OUT; ZRO RG1; LOD RG1 RG1 >CurrentProcID
	CAL >Passeren
	
	/ Depending on the result, either resume the process or skip the remainder of its burst.
	PAS OUT; JIF EQZ >SRH.Success
		JMP >SRH.SuccessSkip
}



/ The Verhogen syscall. Does all the checks to make sure syscall is valid.
#SysVerhogen  %RelSemAdd > !Fn% = {
	/ Make sure the given address is OK to Verhogen.
	CAL >CheckCurProcAddress
	
	/ Then call Verhogen using the given address and resume the process
	MOV RG0 OUT
	LDI RA >SRH.Success; JMP >Verhogen
}



/ Does Passeren on the given I/O's mutex. Does checks to make sure it's valid.
#SysIOMutex  %!Fn% = {
	
	/ Make sure the proc's IOP is OK.
	CAL >CheckIOPAccess
	
	/ Call Passeren.
	MOV RG0 OUT; LDI RG1 >IOMutexSems; ALU ADD RG0 RG1
	ZRO RG1; LOD RG1 RG1 >CurrentProcID
	CAL >Passeren
	
	/ Check if we should resume the proc or not.
	PAS OUT; JIF EQZ >SRH.Success
		JMP >SRH.SuccessSkip
}



/ Does Verhogen on the given I/O's mutex. Does checks to make sure it's valid.
#SysIORelease  %!Fn% = {
	/ Make sure the proc's IOP is OK.
	CAL >CheckIOPAccess
	
	/ Call Verhogen.
	MOV RG0 OUT; LDI RG1 >IOMutexSems; ALU ADD RG0 RG1
	LDI RA >SRH.Success; JMP >Verhogen
}



/ Passeren the WaitTick semaphore
#SysWaitTick  %!Fn% = {
	
	/ Do Passeren(TickWaitSem, CurrentProcID) and skip the remainder of the proc's burst.
	LDI RG0 >TickWaitSem
	ZRO RG1; LOD RG1 RG1 >CurrentProcID
	LDI RA >Dispatcher; JMP >Passeren
}



/ The end of the OS's code segment in memory
#OSEndPoint
