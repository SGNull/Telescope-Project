JMP >Init

(% 	TBOS v2.3
	---------
  
	TSOS is a small-scale operating system for the Telescope Computer System.
	
	TBOS v2.0 is a complete overhall of TBOS, fullfilling most of the features that PandOS does at phases 2 and 3.
	Because of this, TBOS begins to stand out as its own operating system.
	The following are all true for v2.0:
		All interrupts are supported.
			- TICK can be waited on by procs using the WAIT_TICK syscall.
			- PAUS calls the PauseMenu function (just pauses the comptuer, will definitely improve in the future).
			- PVIO just returns an error code to the user process.
			- STOP calls the Shutdown function (terminates root, might improve in the future).
		
		9 syscalls are implemented (11 with v2.3, see 'OS External-Facing Constants' for details).
		
		Semaphores are supported.
	
	v2.1 comes with some important bug fixes and two major optimizations:
		MaxProcNum allows the OS to skip over parts of the process list, significantly increasing performance when working with only a few processes.
		
		SupportList allows the OS to quickly get information about a given process, which should significantly increase performance when working with many processes.
	
	v2.2 comes with some rewrites to existing code, follows TASL 5 conventions, and properly uses the stack. This is a big deal, because it makes writing code in the future much easier.
	
	v2.3 comes with simulated I/O interrupts and a small but very significant change in the way processes are stored. This prompted code rewrites across a lot of the OS, making most of its source code recently written.
%)


/ ----------------------------------------------------Data----------------------------------------------------
(/ ------- Hardware constants -------
	/ Processor constants
	@WORD_SIZE 		 		= 16  / Word size in bits (always must be 16)
	@NUM_IO_DEVICES 		= 32
	@OUT_REG_NUM			= 6
	@RA_REG_NUM				= 7

	@IOP_SHIFT				= 11
	@DRIVE_IOP_GROUP     	= 0
	@DRIVE_PTR_IOP_GROUP 	= 1
	@IOP_GROUP_MASK 		= 0xE000
	@IOP_GROUP_SHIFT 		= 13
	@IOP_DEVICE_MASK		= 0x1800
	@IOP_DEVICE_SHIFT		= 11
	@DRIVE_PTR_BIT 			= 13
	@MAX_UNPROT_IOP_NUM		= 23

	@HI_SHIFT 		= 8
	@HI_MASK		= 0xFF00
	@LO_SHIFT		= >HI_SHIFT
	@LO_MASK 		= 0x00FF

	@EXC_MASK 		= 0x0700
	@EXC_SHIFT 		= 8
	
	@UE_PU_SHIFT 	= 3
	@UE_CE_BIT		= 0
	@UE_STACK_MASK	= 0xF
	
	/ EXC defined by TCS
	@EXC_TICK 	= 0
	@EXC_PAUS 	= 1
	@EXC_PVIO 	= 2
	@EXC_STOP 	= 3
	
	/ EXC defined by processor
	@EXC_CTDZ 	= 4
	@EXC_SYS 	= 5
	@EXC_PRIV 	= 6
	@EXC_OOB 	= 7


	/ Computer determined hardware constants
	@COMP_STATUS_IOP 	= 0xF000
	@RANDOM_IOP 		= >COMP_STATUS_IOP
	@COUNTER_START_IOP 	= 0xE000
	@COUNTER_STOP_IOP 	= 0xE800
	@CONFIG_IOP			= 0xF800


	/ OS determined hardware constants
	@KERNEL_PROC_FLG 	= 0x0004 			/ Exceptions enabled, user mode disabled.
	@USER_PROC_FLG 		= 0x000C			/ Exceptions enabled, user mode enabled.
	@ROOT_PROC_FLG 		= >KERNEL_PROC_FLG	/ Currently, root proc has same privs as Kernel

	@ROOT_DRIVE_IOP 	= 0x0000	/ 0th drive
)


(/ ------- OS Process Information -------

	/ ---- PROCESSES ----
	/ Each process consists of a MainWord, BlockingSemAdd, and BlockingSemNo,
	/ with MainWord = [1-bit Active] [5-bit parent] [5-bit nextSib] [5-bit child]

	@MAX_PROC_COUNT 	= 32
	#ProcMainWords		= [~MAX_PROC_COUNT]
	#ProcSemAdds		= [~MAX_PROC_COUNT]
	#ProcSemNos			= [~MAX_PROC_COUNT]
	
	@SEMADD_OFFSET		= 1
	@SEMNO_OFFSET		= 2

	@PROC_ACTIVE_BIT	= 15
	@PARENT_MASK 		= 0x7C00
	@PARENT_SHIFT 		= 10
	@SIB_MASK 			= 0x03E0
	@SIB_SHIFT 			= 5
	@CHILD_MASK 		= 0x001F

	@ROOT_PROC_ID 		= 0				/ Must be 0
	@NULL_PROC_ID 		= >ROOT_PROC_ID	/ Must be ROOT_PROC_ID

	#ProcCount 			= 0		/ Number of running processes
	#MaxProcNum			= 0		/ The highest active process ID
	#CurrentProcID 		= 0		/ Current running process
	#CurrentStatePtr	= 0		/ The address of the current proc's state
	
	@CTD_VAL 				= 0x0200	/ How many cycles each process is allotted before its turn ends.
	@MAX_DISPATCH_CYCLES 	= 4			/ Max times Dispatcher will loop proc list before deadlock check (must be >1)
	@WAIT_TIME			 	= 0x0400	/ Max cycles the OS will wait upon softblock before running dispatcher again.
	
	/ ---- SUPPORT ----
	/ Not to be confused with support structures, the support list is a list of metadata about each process.
	/ This makes many calculations within the operating system significantly faster, and is very easy to maintain.
	#SupportList	= [~MAX_PROC_COUNT]
	@SUP_ACTIVE_BIT		= 0  / Bit 0 - Proc is active
	@SUP_IS_THREAD_BIT	= 1  / Bit 1 - Proc is a thread (of another process)
	@SUP_WAIT_BIT		= 2  / Bit 2 - Proc is waiting on anything
	@SUP_OS_WAIT_BIT	= 3  / Bit 3 - Proc is waiting on OS semaphore
	@SUP_IO_WAIT_BIT	= 4  / Bit 4 - Proc is waiting on I/O read/write semaphore
	@SUP_IO_TYPE_BIT	= 5  / Bit 5 - If 1, proc is waiting on write, else proc is waiting on read
	
	@INIT_SUP_WORD		= 0b0001  / Active, but nothing else.
)


(/ ------- OS Memory Information -------
	
	/ ---- STATES ----
	/ EXA and CTD are constant, PC is in the OS, and IO doesn't make sense to store, so 12 words per state
	/ Each state has the following format: RG0-7, FLG, SP, EPC, HLB
	@NUM_STATE_REGS		= 12  / Number of registers which should be stored (always 12)
	@PROC_CxSTATE_S 	= 384 / 32 max proc x 12 words per proc state = 384
	#StateList 			= [~PROC_CxSTATE_S]
	@FLG_OFFSET 		= 8
	@SP_OFFSET 			= 9
	@EPC_OFFSET 		= 10
	@HLB_OFFSET 		= 11
	
	
	/ ---- ALLOCATION ----
	@CHUNK_SIZE 		= 0x0400
	@NUM_CHUNKS 		= 64		/ Must be (2^16)/CHUNK_SIZE
	@BMP_WORDS 			= 4			/ Must be NUM_CHUNKS/16, and under 16
	@BMP_WORDS_2S_EXP	= 2			/ Must be sqrt(BMP_WORDS)
	#MallocBMPs 		= [~BMP_WORDS]
	
	
	/ ---- SEMAPHORES ----
	
	/ NUM_IO_DEVICES number of 1's
	#IOMutexSems = [1, 1, 1, 1, 
					1, 1, 1, 1,
					1, 1, 1, 1,
					1, 1, 1, 1,
					1, 1, 1, 1,
					1, 1, 1, 1,
					1, 1, 1, 1,
					1, 1, 1, 1]
	
	/ All OS soft blocking semaphores must be between SEM_START and SEM_END
	#SEM_START
		#IOReadSems		= [~NUM_IO_DEVICES]
		#IOWriteSems 	= [~NUM_IO_DEVICES]
		#TickWaitSem 	= 0
	#SEM_END
	
	#SoftBlockCount 	= 0		/ Number of procs waiting on I/O
	
	
	/ ---- MISC ----
	#MarkInst: ALU SET RG3 RG0
	#UnmarkInst: ALU UST RG3 RG0
)


(/ ------- OS External-Facing Constants -------
	@TSFS_ENTRY_SIZE = 2
	
	/ Syscode name:		   SysNo:   Arguments:				Description:
	@SYSCODE_LOAD_PROGRAM 	= 0   / FileNo, IsKernel?		Load the given FileNo as a child of the current process.
	@SYSCODE_MAKE_THREAD 	= 1   / PC, SP, IsKernel?		Create a new thread of the current process.
	@SYSCODE_TERMINATE		= 2   / 						Terminate the current process.
	@SYSCODE_GIVE_UP_TURN 	= 3   / 						Skip the remainder of the current process's CPU burst.
	@SYSCODE_PASSEREN		= 4   / SemAdd					Wait in line on the given semaphore.
	@SYSCODE_VERHOGEN		= 5   / SemAdd					Signal the given semaphore.
	@SYSCODE_IO_MUTEX		= 6   / IOP set					Gain mutual exclusion over the given I/O device.
	@SYSCODE_IO_RELEASE		= 7   / IOP set					Release mutual exclusion over the given I/O device.
	@SYSCODE_WAIT_TICK		= 8   / 						Wait for the TICK interrupt to occur.
	@SYSCODE_IO_WAIT_WRITE	= 9	  / IOP set					Wait in line for the given I/O to send a PWT signal.
	@SYSCODE_IO_WAIT_READ	= 10  / IOP set					Wait in line for the given I/O to send a PRD signal.
)


(/ ------- Status & Return Codes -------
	
	/ Status codes
	@START_CODE 			= 1		  / The OS has been loaded into the computer's memory.
	@RUN_CODE 				= 2		  / The OS has successfully set up the environment and is now running processes.
	@PAUSE_CODE				= 0x1111  / The computer is currently paused due to the PAUS interrupt.
	@SHUTDOWN_CODE			= 0x2222  / If you resume the computer, it will begin shutting down.
	@END_CODE 				= 0x600D  / The OS has successfully come to a stop.
	@DEADLOCK_CODE			= 0xDEAD  / All procs are waiting on semaphores that will never be signalled.
	@BAD_START_ERROR 		= 0xFF00  / The OS has encountered a critical error attempting to set up the environment.
	@UNKNOWN_EXC_ERROR 		= 0xFF01  / The OS has encountered a critical error where EXC is not 3 bit.
	
	/ Basic return codes
	@UNKNOWN_SYSCODE_ERROR 	= 0xFF02  / User proc invoked an unknown syscode.
	@PVIO_ERROR				= 0xFF03  / User proc attempted to read/write a protected device.
	
	/ Syscall return codes (all syscalls return these, or UNKNOWN_SYSCODE_ERROR)
	@SYS_SUCCESSFUL			= 1		  / The operation was successful.
	@SYS_MAX_PROCS			= 0xF000  / There is no room for another proc.
	@SYS_OUT_OF_MEM			= 0xF001  / There is not enough room in memory.
	@SYS_MISSING_FILE		= 0xF002  / The file in question is missing.
	@SYS_BAD_IOP			= 0xF003  / IOP was not set correctly for this operation.
	@SYS_ATTEMPTED_OOB		= 0xF004  / The user process attempted to work with addresses out-of-bounds.
	@SYS_ATTEMPTED_PRIV		= 0xF005  / The user process attempted a privileged operation.
	@SYS_ATTEMPTED_OS		= 0xF006  / The process attempted to alter/access the OS directly.
)

(/ ------- UI Strings -------
	@NEWLINE = '
	'
	
	#UIStrTBOS = "TBOS v2.3 loading..."
	#UIStrInit = "Enter the root drive number, or nothing to use default loading behavior: "
	#UIStrInputErr = "Error: not a valid input."
)



/ ------------------------------------------------Base Functions----------------------------------------------



/ Initializes the OS environment
#Init  %!Fn% = {
	/ Set the status
	LDI FLG >COMP_STATUS_IOP; LDI IO >START_CODE
	
	/ Start the cycle counter
	LDI FLG >COUNTER_START_IOP; MOV IO RG0  / Just have to write any value to it to start
	
	/ Calculate the OS size in chunks in RG1
	LDI RG1 >OSEndPoint; LDI RG0 >CHUNK_SIZE; ALU DIV RG1 RG0
	ALI ADD RG1 2  / Add the stack chunk + 1 for remainder
	
	/ Call MarkBits(start chunk, size)
	LDI RG0 >NUM_CHUNKS; DEC RG0  / Adjust for stack (will be at end of mem)
	CAL >MarkBits
	
	/ Startup UI goes here
	
	/ Load the root program
	LDI FLG >ROOT_DRIVE_IOP; CAL >LoadProgLoadable
	AIN ADD OUT 1; JIF NCR >Ini.OK
		LDI RG0 >BAD_START_ERROR; JMP >StatusEnd
	#Ini.OK
	
	/ Create the root thread
	MOV RG0 OUT; LDI FLG >ROOT_PROC_FLG
	CAL >MakeChildThread
	
	/ Set the new status
	LDI FLG >COMP_STATUS_IOP; LDI IO >RUN_CODE
	
	/ Make sure the dispatcher runs root first
	NUL RG0; STR RG0 RG0 >CurrentProcID
	
	/ Send control off to the dispatcher
	JMP >Dispatcher
}



/ Sets the status to RG0 and *permanently* halts
#StatusEnd  %!Fn% = {
	LDI FLG >COUNTER_STOP_IOP
	MOV IO RG0
	LDI FLG >COMP_STATUS_IOP
	MOV IO RG0
	
	/ Force permanent HLT. Maybe allow reboots in the future?
	#StE.HLT
	HLT; JMP >StE.HLT
}



/ The scheduler/dispatcher runs the next process (and checks for done/deadlock/etc.)
#Dispatcher  %!Fn% = {
	/ Check if we're done
	ZRO RG0; LOD RG0 RG0 >ProcCount
	PAS RG0; JIF EQZ >Dis.Done
	
	/ If not, setup registers for loop
	/ RG0 - Next proc num
	/ RG1 - Max proc num + 1
	/ RG2 - Support word
	/ SF1 - Num loops
	/ OUT - Starting proc num
	ZRO RG0; LOD RG0 RG0 >CurrentProcID; MOV OUT RG0
	ZRO RG1; LOD RG1 RG1 >MaxProcNum; INC RG1
	ZRO SF1
	ALU MOD OUT RG1 / Fixes issues with CurrentProc > MaxProcID after Terminate
	
	#Dis.GetNext
		/ Increment and (possibly) loop the next proc num.
		INC RG0; ALU MOD RG0 RG1
		
		/ Check if we've looped (too many times)
		CMP RG0 OUT; JEQ >Dis.Looped #Dis.Continue
		
		/ The process must be active
		LOD RG2 RG0 >SupportList; AIN SET RG2 >SUP_ACTIVE_BIT; JIF NCR >Dis.GetNext
		
			/ And not blocked
			AIN SET RG2 >SUP_WAIT_BIT; JIF NCR >Dis.FoundProc
			
				/ Unless it's waiting on I/O
				AIN SET RG2 >SUP_IO_WAIT_BIT; JIF NCR >Dis.GetNext
				
					/ Then it must be the last proc on its waitlist
					LOD RG3 RG0 >ProcSemNos; ICC RG3; JIF NCR >Dis.GetNext
					
						/ And the I/O must be doing the given operation.
						MOV RG3 RG0; ALI MUL RG3 >NUM_STATE_REGS; ALI ADD RG3 >FLG_OFFSET
						LOD FLG RG3 >StateList
						AIN SET RG2 >SUP_IO_TYPE_BIT; JIF CAR >Dis.IsWrite
							/ It must be reading
							JIF PNR >Dis.GetNext
							JMP >Dis.VProc
						#Dis.IsWrite
							/ It must be writing
							JIF PNW >Dis.GetNext
						#Dis.VProc
						
							/ If so, verhogen the semaphore and run this proc
							MOV SF0 RG0
							LOD RG0 RG0 >ProcSemAdds; CAL >Verhogen
							MOV RG0 SF0
	#Dis.FoundProc
	
	/ Store the new current process
	STR RG0 RG0 >CurrentProcID
	
	/ Find the process state and store it's address
	ALI MUL RG0 >NUM_STATE_REGS; LDI RG1 >StateList; ALU ADD RG0 RG1
	STR RG0 RG0 >CurrentStatePtr
	
	/ Load the state and RSM the process
	LOD EPC RG0 >EPC_OFFSET
	LDI EXA >ExHandler
	LDI CTD >CTD_VAL
	LOD HLB RG0 >HLB_OFFSET
	LOD FLG RG0 >FLG_OFFSET
	LOD SP RG0 >SP_OFFSET
	LOD RA RG0 7
	LOD OUT RG0 6
	LOD SF1 RG0 5
	LOD SF0 RG0 4
	LOD RG3 RG0 3
	LOD RG2 RG0 2
	LOD RG1 RG0 1
	LOD RG0 RG0 0
	
	RSM
	
	
	#Dis.Looped
	/ Increment the loop count, and check if we may be deadlocked
	INC SF1; CMI SF1 >MAX_DISPATCH_CYCLES; JNE >Dis.Continue
	
	#Dis.MaybeDeadlock
	/ Check if SoftBlockCount is 0 (deadlock)
	ZRO RG0; LOD RG0 RG0 >SoftBlockCount
	PAS RG0; JIF NEZ >WaitForInt
	
	/ If so, deadlock.
	LDI RG0 >DEADLOCK_CODE
	JMP >StatusEnd
	
	#Dis.Done
	LDI RG0 >END_CODE
	JMP >StatusEnd
}



/ The return point for all programs. Handles any exceptions that occur.
#ExHandler  %!Fn% = {
	/ Get the current proc's state address in RG0
	STR RG0 RG0 >ExH.TempRG0
	ZRO RG0; LOD RG0 RG0 >CurrentStatePtr
	
	/ Now store the old RG0 (the temp reg) into the proc state's RG0
	STR RG1 RG0 1
	ZRO RG1; LOD RG1 RG1 >ExH.TempRG0; STR RG1 RG0 0
	
	/ Finally, store off the rest of the registers
	/ Before trying to optimize this: having considered all ramifications, this is the best place to do this.
	STR RG2 RG0 2
	STR RG3 RG0 3
	STR SF0 RG0 4
	STR SF1 RG0 5
	STR OUT RG0 6
	STR RA RG0 7
	STR SP RG0 >SP_OFFSET
	STR EPC RG0 >EPC_OFFSET
	STR FLG RG0 >FLG_OFFSET
	
	/ Ready the stack for the OS
	ZRO SP
	
	
	/ For in-OS waiting
	#ExH.Skip
	
	/ Get EXC in RG0
	LDI RG0 >EXC_MASK; ALU AND RG0 FLG; ALI SRB RG0 >EXC_SHIFT
	
	/ Check if the proc's CPU burst is up.
	CMI RG0 >EXC_CTDZ; JEQ >Dispatcher
	
	/ Check for Syscall
	CMI RG0 >EXC_SYS; JEQ >SysHandler
	
	/ Check if it's unrecoverable
	CMI RG0 >EXC_PRIV; JEQ >TerminateCurrent
	CMI RG0 >EXC_OOB; JEQ >TerminateCurrent
	
	/ Check if it's from the computer's user
	CMI RG0 >EXC_PAUS; JEQ >PauseMenu
	CMI RG0 >EXC_STOP; JEQ >Shutdown
	
	/ Check if it's from the computer
	CMI RG0 >EXC_TICK; JEQ >UnblockAllTick
	CMI RG0 >EXC_PVIO; JNE >ExH.UnknownEXC
		/ If the process tried to access a privileged I/O device, give it an error output and skip it.
		ZRO RG0; LOD RG0 RG0 >CurrentStatePtr
		LDI RG1 >PVIO_ERROR; STR RG1 RG0 >OUT_REG_NUM
		JMP >Dispatcher
	
	/ Else the OS has errored in some way (EXC must be one of the above), so halt.
	#ExH.UnknownEXC
	LDI RG0 >UNKNOWN_EXC_ERROR
	JMP >StatusEnd
}
#ExH.TempRG0 = 0



/ Resume the current process (if it's not waiting)
#ResumeProc  %!Fn% = {
	ZRO RG0; LOD RG0 RG0 >CurrentProcID
	LOD RG0 RG0 >SupportList; AIN SET RG0 >SUP_WAIT_BIT; JIF CAR >Dispatcher
	
	/ Restore the state
	/ Note: CTD is not stored if we wanted to charge procs for OS cycles (since lack sup. structs to delegate operations).
	/ We'd have to do this relative to the TCS cycle counter, since CTDZ could occur if Ex = 1.
	ZRO RG0; LOD RG0 RG0 >CurrentStatePtr
	LOD SP RG0 >SP_OFFSET
	LOD FLG RG0 >FLG_OFFSET
	LOD RA RG0 7
	LOD OUT RG0 6
	LOD SF1 RG0 5
	LOD SF0 RG0 4
	LOD RG3 RG0 3
	LOD RG2 RG0 2
	LOD RG1 RG0 1
	LOD RG0 RG0 0
	
	/ Resume the process
	RSM
}



/ ----------------------------------------------Memory Management---------------------------------------------



/ Loads a file at IOP into memory
/ IMPORTANT: DOES NOT MARK THE BITMAP
#LoadFile  %MemStart, FileSize w/ IOP & DrivePTR% = {
	/ Write the file to memory
	PAS RG1; JIF EQZ >LoF.Done
	#LoF.LoadLoop
		STR IO RG0 0
		INC RG0
	DCC RG1; JIF NEZ >LoF.LoadLoop
	
	/ Finally, return
	#LoF.Done
	RET
}



/ Returns the number of the first 0 bit, or NULL if none are found
#FindOpenMemory  %Size > FirstChunkNum|NULL% = {
	/ Setup registers:
	/ RG0: NUM_CHUNKS / Bits left to find
	/ RG1: Current bit
	/ RG2: Current word number
	/ RG3: Current word
	/ SF0: Size
	
	PSH 1
	STR SF0 SP 0
	
	MOV SF0 RG0
	LDI RG0 >NUM_CHUNKS
	ZRO RG1
	ZRO RG2; LOD RG3 RG2 >MallocBMPs
	
	#FOM.OpenSearch
		/ Immediately check for wrap around (if so, we're done).
		CMP RG1 RG0; JGE >FOM.OutOfMem
		
		/ Store off the current bit for now.
		MOV OUT RG1
		
		/ Increment bit, and if word overflow get next word.
		INC RG1; AIN SRB RG1 4; JIF CAR >FOM.SNoverflow
			INC RG2; ALI UST RG2 >BMP_WORDS_2S_EXP; LOD RG3 RG2 >MallocBMPs
		#FOM.SNoverflow
		
		/ If the bit is not open, loop.
		AFN SET RG3 OUT; JIF CAR >FOM.OpenSearch
		
		/ If not, setup RG0 for OpenCheck
		MOV RG0 SF0
		
		#FOM.OpenCheck
			/ Decrement number of bits to find, and if zero, we're done.
			DCC RG0; JIF EQZ >FOM.Done
			
			/ Else, increment bit and check for word overflow.
			INC RG1; AIN SRB RG1 4; JIF CAR >FOM.CNoverflow
				INC RG2; ALI UST RG2 >BMP_WORDS_2S_EXP; LOD RG3 RG2 >MallocBMPs
			#FOM.CNoverflow
			
			/ If the bit is open, loop again.
			AFN SET RG3 RG1; JIF NCR >FOM.OpenCheck
		
		/ If not, setup RG0 for outer loop and goto it.
		/ NOTE: This repeats the same check (RG1 is unchanged), but it will have the same outcome so it does not matter.
		LDI RG0 >NUM_CHUNKS; JMP >FOM.OpenSearch
	
	#FOM.OutOfMem
	NUL OUT
	
	#FOM.Done
	LOD SF0 SP 0
	POP 1
	RET
}



/ Turns on bits StartChunk through StartChunk+Size-1 inclusive
#MarkBits  %StartChunk, Size% = {	
	/ Setup and jump to ModifyBits
	ZRO RG2; LOD RG2 RG2 >MarkInst
	JMP >ModifyBits
}

/ Turns off bits StartChunk through StartChunk+Size-1 inclusive
#UnmarkBits  %StartChunk, Size% = {	
	/ Setup and jump to ModifyBits
	ZRO RG2; LOD RG2 RG2 >UnmarkInst
	JMP >ModifyBits
}

/ Shell function for UnmarkBits and MarkBits DO NOT CALL
#ModifyBits {
	/ Modify code according to RG2
	STR RG2 RG2 >MoB.ModBit
	
	/ Setup the following:
	/ RG0: Current bit (already set)
	/ RG1: End bit
	/ RG2: Word number
	/ RG3: Current word
	ALU ADD RG1 RG0
	MOV RG2 RG0; ALI SRB RG2 4
	LOD RG3 RG2 >MallocBMPs
	
	#MoB.Loop
		/ If we're at the end, we're done.
		CMP RG0 RG1; JEQ >MoB.Done
		
		/ Do the operation
		#MoB.ModBit: NOP	/ ALU XXX RG3 RG0
		
		/ Go to next bit, and if no word overflow, loop again.
		INC RG0; AIN SRB RG0 4; JIF CAR >MoB.Loop
		
		/ Else, store word, and load next word.
		STR RG3 RG2 >MallocBMPs
		INC RG2; ALI UST RG2 >BMP_WORDS_2S_EXP  / Does wrap-around automatically :D
		LOD RG3 RG2 >MallocBMPs
		JMP >MoB.Loop
		
	#MoB.Done
	
	STR RG3 RG2 >MallocBMPs
	
	/ Return
	RET
}



/ ------------------------------------------------Process Tree------------------------------------------------



/ Creates child thread for current proc with given HLB and FLG
#MakeChildThread  %NewHLB w/ FLG > ProcNum% = {
	PSH 1
	STR SF0 SP 0
	
	/ Store off FLG for now
	MOV SF0 FLG
	
	/ Find inactive thread (ProcNo = RG1)
	NUL RG1
	#MCT.Search
		INC RG1
		LOD RG2 RG1 >ProcMainWords
	AIN SET RG2 >PROC_ACTIVE_BIT; JIF CAR >MCT.Search
	
	/ Set RG3 to 0 for quicker ops.
	ZRO RG3
	
	/ Activate proc and zero out semaphore fields
	ZRO RG2; ALI SET RG2 >PROC_ACTIVE_BIT; STR RG2 RG1 >ProcMainWords
	STR RG3 RG1 >ProcSemAdds; STR RG3 RG1 >ProcSemNos
	
	/ Increment ProcCount
	LOD RG2 RG3 >ProcCount
	INC RG2; STR RG2 RG2 >ProcCount
	
	/ Check if this is above MaxProcNum.
	LOD RG2 RG3 >MaxProcNum
	CMP RG1 RG2; JLT >MCT.Smaller
		/ If it's not less than, it's greater than, so set MaxProcNum
		STR RG1 RG1 >MaxProcNum
	#MCT.Smaller
	
	/ Initialize its support list word
	LDI RG2 >INIT_SUP_WORD; STR RG2 RG1 >SupportList
	
	/ Get the location of its state in RG2
	MOV RG2 RG1; ALI MUL RG2 >NUM_STATE_REGS
	LDI RG3 >StateList; ALU ADD RG2 RG3
	
	/ Zero out all registers except FLG and HLB
	ZRO RG3
	STR RG3 RG2 0
	STR RG3 RG2 1
	STR RG3 RG2 2
	STR RG3 RG2 3
	STR RG3 RG2 4
	STR RG3 RG2 5
	STR RG3 RG2 6
	STR RG3 RG2 7
	STR RG3 RG2 >EPC_OFFSET
	STR RG3 RG2 >SP_OFFSET
	
	/ Set FLG and HLB
	MOV RG3 SF0
	STR RG3 RG2 >FLG_OFFSET
	STR RG0 RG2 >HLB_OFFSET
	
	
	/ InsertChild(ThisProcNum)
	MOV RG0 RG1
	MOV OUT RG0
	
	MOV SF0 RA
	CAL >InsertChild
	MOV RA SF0
	
	/ Return
	LOD SF0 SP 0
	POP 1
	RET
}



/ Adds the given process as a child to the current process
#InsertChild  %ProcNum% = {
	/ Quick check if it's root
	PAS RG0; JIF EQZ >InC.Done
	
	/ Get the main word of ProcNum in RG1
	LOD RG1 RG0 >ProcMainWords
	
	/ Zero out the parent and sib
	LDI RG2 >SIB_MASK; ALU NOT RG2 RG2; ALU AND RG1 RG2
	LDI RG2 >PARENT_MASK; ALU NOT RG2 RG2; ALU AND RG1 RG2
	
	/ Set parent to CurrentProcID (RG2) and store the main word
	ZRO RG2; LOD RG2 RG2 >CurrentProcID
	MOV RG3 RG2; ALI SLB RG3 >PARENT_SHIFT
	ALU OR RG1 RG3; STR RG1 RG0 >ProcMainWords
	
	/ Check if current proc (RG2) has children (RG1) (main word in RG3)
	LOD RG3 RG2 >ProcMainWords
	LDI RG1 >CHILD_MASK; ALF AND RG1 RG3; JIF NEZ >InC.FindLastSib
		/ Case 1: current proc has no children
		ALU OR RG3 RG0; STR RG3 RG2 >ProcMainWords
		JMP >InC.Done
		
	/ Case 2: current proc has children
	/ Loop through siblings to find the endpoint
	#InC.FindLastSib
		/ Main word in RG2, proc num in RG1
		LOD RG2 RG1 >ProcMainWords
		LDI RG3 >SIB_MASK; ALF AND RG3 RG2; JIF EQZ >InC.FoundLast
		ALI SRB RG3 >SIB_SHIFT; MOV RG1 RG3; JMP >InC.FindLastSib
	#InC.FoundLast
	
	/ Set proc as sibling of last sib (MW in RG1, num in RG2) and we're done
	ALI SLB RG0 >SIB_SHIFT
	ALU OR RG2 RG0; STR RG2 RG1 >ProcMainWords
	#InC.Done

	RET
}



/ Removes the given process as a child from the process tree
/ Does not alter the proc's main word
#RemoveChild  %ProcNum% = {
	PSH 1
	STR SF0 SP 0

	/ Case 1 - Proc is root, nothing to do
	PAS RG0; JIF EQZ >ReC.Done
	
	/ Get the process word in RG1
	LOD RG1 RG0 >ProcMainWords
	
	/ Get the parent's main word in RG3 (and num in RG2)
	LDI RG2 >PARENT_MASK; ALU AND RG2 RG1; ALI SRB RG2 >PARENT_SHIFT
	LOD RG3 RG2 >ProcMainWords
	
	/ Check if the process is the first child (SF0)
	LDI SF0 >CHILD_MASK; ALU AND SF0 RG3
	CMP SF0 RG0; JNE >ReC.IsSibling
		/ Case 2 - Proc is the first child, set parent's child id to proc's sib id
		LDI SF0 >CHILD_MASK; ALU NOT SF0 SF0; ALU AND RG3 SF0
		LDI SF0 >SIB_MASK; ALU AND SF0 RG1; ALI SRB SF0 >SIB_SHIFT  / Get child in SF0
		ALU OR RG3 SF0; STR RG3 RG2 >ProcMainWords
		JMP >ReC.Done
		
	#ReC.IsSibling
		/ Case 3 - Proc is a sibling, "bridge" over the process
		#ReC.SibLoop
			/ Get the main word in RG2 
			LOD RG2 SF0 >ProcMainWords
		
			/ Get the sibling's ProcNo in RG3
			LDI RG3 >SIB_MASK; ALU AND RG3 RG2; ALI SRB RG3 >SIB_SHIFT
			
			/ If this is our ProcNum (RG0), then break
			CMP RG3 RG0; JEQ >ReC.FoundSib
			
			/ Else, ready SF0 to loop again
			MOV SF0 RG3; JMP >ReC.SibLoop
		#ReC.FoundSib
		
		/ Found the sibling, bridge over the process.
		/ SF0 is the ProcNum of prev sib, RG2 is its main word.
		
		/ Get the current proc's sibling field unshifted in RG1.
		LDI RG3 >SIB_MASK; ALU AND RG1 RG3
		
		/ Remove the previous sibling's sibling field and update it.
		ALU NOT RG3 RG3; ALU AND RG2 RG3
		ALU OR RG2 RG1; STR RG2 SF0 >ProcMainWords
	
	#ReC.Done
	LOD SF0 SP 0
	POP 1
	RET
}



/ ----------------------------------------------Primary Functions---------------------------------------------



/ For now does not do much, but in the future there will be extra features associated with this.
/ When the user triggers the PAUS interrupt, this subroutine is called.
#PauseMenu  %!Fn% = {
	LDI FLG >COMP_STATUS_IOP; LDI IO >PAUSE_CODE
	HLT
	JMP >ResumeProc
}



/ Shuts the computer down.
/ Perhaps this should give procs an opportunity to stop themselves in the future.
/ Maybe start by blocking all new threading and loading attempts?
/ AND the above only happens the first time shutdown is called. The second time it just terminates root.
#Shutdown  %!Fn% = {
	/ For now, just pauses and terminates root, terminating all other procs.
	LDI FLG >COMP_STATUS_IOP; LDI IO >SHUTDOWN_CODE
	HLT
	
	ZRO RG0; CAL >Terminate
	JMP >Dispatcher
}



/ When the TICK interrupt occurs, this function is called.
#UnblockAllTick  %!Fn% = {
	/ Do UnblockAll(TickWaitSem)
	LDI RG0 >TickWaitSem
	CAL >UnblockAll
	
	/ Process interrupt
	LDI FLG >CONFIG_IOP; ZRO IO
	
	/ Resume proc
	JMP >ResumeProc
}



/ Deactivates, deallocates, and un-childs ProcNum and all its children.
/ Now handles semaphores and selective deallocation (if thread, don't dealloc), along with MaxProcNum
/ Shell function for RecursiveTerm
#Terminate  %ProcNum% = {
	PSH 1
	STR RA SP 0
	
	/ First, call RecursiveTerm
	ZRO RG1; CAL >RecursiveTerm
	
	/ Now we have to (probably) update MaxProcNum
	/ Get MaxProcNum
	ZRO RG0; LOD RG0 RG0 >MaxProcNum
	#Ter.Loop
		/ Make sure it's not root
		PAS RG0; JIF EQZ >Ter.Done
		
		/ Check the support word to see if its active, and if so this is MaxProcNum
		LOD RG1 RG0 >SupportList; AIN SET RG1 >SUP_ACTIVE_BIT; JIF CAR >Ter.Done
		
		/ Decrement and loop
		DEC RG0; JMP >Ter.Loop
	#Ter.Done
	
	/ Whatever is in RG0 is the correct MaxProcNum
	STR RG0 RG0 >MaxProcNum
	
	LOD RA SP 0
	POP 1
	RET
}

/ Do not call unless you're Terminate!
#RecursiveTerm  %ProcNum, Recursed?%{
	PSH 2; STR SF0 SP 0; STR RA SP 1
	
	/ Copy arg0 to SF0
	MOV SF0 RG0
	
	/ If recursing, try to call RecursiveTerm on sibling
	PAS RG1; JIF EQZ >ReT.NotRecurse
		/ Check for siblings.
		LOD RG2 RG0 >ProcMainWords
		LDI RG0 >SIB_MASK; ALF AND RG0 RG2
		JIF EQZ >ReT.Recurse
			/ Else, call RecursiveTerm on it (RG1 is already 1)
			ALI SRB RG0 >SIB_SHIFT
			LDI RA >ReT.Recurse; JMP >RecursiveTerm
			
	#ReT.NotRecurse
		/ If not recursing, call RemoveChild
		CAL >RemoveChild
		
	#ReT.Recurse
	/ ----- Past this point, argument 1 (RG1) is no longer needed -----
	
	
	/ If the process is waiting on a SemAdd, we need to verhogen, but only update procs BEHIND this proc on the wait list.
	/ This means updating softblockcount, incrementing the semaphore, and changing the SemNo of *these specific* procs.
	/ We do not wake up any procs because all procs under consideration are on a wait list.
	
	/ Get the support word in RG1, and check if the proc is blocked
	LOD RG1 SF0 >SupportList; AIN SET RG1 >SUP_WAIT_BIT; JIF NCR >ReT.VSkip
	
		/ Last usage of support word to check if blocked on OS semaphore
		AIN SET RG1 >SUP_OS_WAIT_BIT; JIF NCR >ReT.NotOSSem
			/ If the semaphore is in the OS, decrement softblockcount
			ZRO RG1; LOD RG1 RG1 >SoftBlockCount
			DEC RG1; STR RG1 RG1 >SoftBlockCount
		#ReT.NotOSSem
		
		/ Incrementing [SemAdd] (RG1)
		LOD RG1 SF0 >ProcSemAdds
		LOD RG2 RG1 0; INC RG2; STR RG2 RG1 0
		
		/ Now begin looping through each proc (RG0) in proc list (RG2 is max, RG1 is SemAdd)
		NUL RG0; ZRO RG2; LOD RG2 RG2 >MaxProcNum; INC RG2
		#ReT.VLoop
			/ Loop
			INC RG0; CMP RG0 RG2; JEQ >ReT.VSkip
			
			/ Check if the SemAdd is equal (and if not, go to the next proc)
			LOD RG3 RG0 >ProcSemAdds; CMP RG3 RG1; JNE >ReT.VLoop
			
			/ Now check if its SemNo is lower (and if not, go to next proc)
			LOD RG3 RG0 >ProcSemNos; CMP RG3 RG1; JGE >ReT.VLoop
			
			/ Finally, increment the SemNo if it passed all the other checks, and loop.
			INC RG3; STR RG3 RG0 >ProcSemNos
			JMP >ReT.VLoop
		#ReT.VSkip
		
		/ Finally, clear the SemAdd and SemNo of the current proc.
		ZRO RG1; STR RG1 SF0 >ProcSemAdds; STR RG1 SF0 >ProcSemNos
	/ ---------- End of semaphore code ----------
	
	
	/ We still need to:
	/ A) Deallocate the proc's memory only if it's not a thread.
	/ B) Recurse downwards in the tree.
	/ C) Formally delete the process (deactivate proc, decrement ProcCount, clear support word).
	
	/ Check if this is a child thread (and skip dealloc if it is)
	LOD RG1 SF0 >SupportList; AIN SET RG1 >SUP_IS_THREAD_BIT; JIF CAR >ReT.SkipDealloc
	
	/ Get current proc's HLB(RG2)
	MOV RG2 SF0; ALI MUL RG2 >NUM_STATE_REGS; ALI ADD RG2 >HLB_OFFSET
	LOD RG2 RG2 >StateList
		
	#ReT.Dealloc
		/ Call UnmarkBits(Start, Size)
		MOV RG1 RG2; LDI RG3 >CHUNK_SIZE; ALU DIV RG1 RG3
		LDI RG0 >LO_MASK; ALU AND RG0 RG2; ALI SLB RG0 >LO_SHIFT; ALU DIV RG0 RG3
		CAL >UnmarkBits
	#ReT.SkipDealloc
	
	/ Call RecursiveTerm on child procs (if they exist)
	LOD RG2 SF0 >ProcMainWords
	LDI RG3 >CHILD_MASK; ALF AND RG2 RG3
	JIF EQZ >ReT.NoChilds
		MOV RG0 RG2; NUL RG1; CAL >RecursiveTerm
	#ReT.NoChilds
	
	/ Deactivate the proc
	ZRO RG0; STR RG0 SF0 >ProcMainWords
	
	/ Decrement ProcCount
	ZRO RG0; LOD RG0 RG0 >ProcCount; DEC RG0; STR RG0 RG0 >ProcCount
	
	/ Clear its support word
	ZRO RG0; STR RG0 SF0 >SupportList
	
	/ Return
	LOD SF0 SP 0; LOD RA SP 1; POP 2
	RET
}



/ The Passeren (Wait) semaphore operation.
/ Sets OS_WAIT bit in support list.
#Passeren  %Address, ProcNum > ProcMustWait?% = {
	/ Decrement semaphore (SemNo in RG2)
	LOD RG2 RG0 0; DEC RG2; STR RG2 RG0 0
	
	/ If still positive, skip over the rest of Passeren
	PAS RG2; JIF GEZ >Pas.Skip
		/ Else, set SemAdd and SemNo
		STR RG0 RG1 >ProcSemAdds; STR RG2 RG1 >ProcSemNos
		
		/ Add WAIT to the support word (RG3).
		LOD RG3 RG1 >SupportList; ALI SET RG3 >SUP_WAIT_BIT
		
		/ Check if SemAdd is an OS semaphore.
		LDI RG2 >SEM_START; CMP RG0 RG2; JLT >Pas.NotOSSem
		LDI RG2 >SEM_END; CMP RG0 RG2; JGE >Pas.NotOSSem
			/ If so, increment SoftBlockCount
			ZRO RG2; LOD RG2 RG2 >SoftBlockCount
			INC RG2; STR RG2 RG2 >SoftBlockCount
			
			/ And add OS_WAIT to the support word
			ALI SET RG3 >SUP_OS_WAIT_BIT
		#Pas.NotOSSem
		
	/ Update the support word
	STR RG3 RG1 >SupportList
		
	/ And return 1 (proc must wait)
	LDI OUT 1; JMP >Pas.Done
		
	#Pas.Skip
	/ Return 0 (proc doesn't have to wait)
	ZRO OUT
	
	#Pas.Done
	RET
}



/ The Verhogen (Signal) semaphore operation.
#Verhogen  %Address% = {
	/ Increment the semaphore
	LOD RG1 RG0 0; INC RG1; STR RG1 RG0 0
	
	/ Now start looping through each process (RG1 = ProcNum, RG2 = Max)
	NUL RG1; ZRO RG2; LOD RG2 RG2 >MaxProcNum; INC RG2
	#Ver.Loop
		/ Loop
		INC RG1; CMP RG1 RG2; JEQ >Ver.Done
		
		/ Get the SemAdd (and loop again if it's not the same)
		LOD RG3 RG1 >ProcSemAdds; CMP RG3 RG0; JNE >Ver.Loop
		
		/ INC SemNo and check if the proc is done waiting (it can't miss 0 cause we only INC/DEC)
		LOD RG3 RG1 >ProcSemNos; INC RG3; STR RG3 RG1 >ProcSemNos
		PAS RG3; JIF NEZ >Ver.Loop
		
		/ If so, remove SemAdd and remove WAITs from the support word
		STR RG3 RG1 >ProcSemAdds
		
		LOD RG3 RG1 >SupportList
		ALI UST RG3 >SUP_WAIT_BIT; ALI UST RG3 >SUP_IO_WAIT_BIT
		
		/ Check if semaphore is in OS
		AIN SET RG3 >SUP_OS_WAIT_BIT; JIF NCR >Ver.NotInOS
			/ If so, decrement SoftBlockCount
			ZRO OUT; LOD OUT OUT >SoftBlockCount
			DEC OUT; STR OUT OUT >SoftBlockCount
			
			/ And remove OS_WAIT from the support word
			ALI UST RG3 >SUP_OS_WAIT_BIT
		#Ver.NotInOS
		
		/ Update the support word.
		STR RG3 RG1 >SupportList
		
		/ Loop
		JMP >Ver.Loop
	#Ver.Done
	
	/ When done, return
	RET
}



/ Unblocks all processes associated with the given semaphore.
#UnblockAll  %SemAdd% = {	
	/ Loop through all procs (RG1 = ProcNum, RG2 = Count)
	NUL RG1; ZRO RG2
	#UnA.Loop
		/ Do loop.
		INC RG1
		LDI RG3 >MAX_PROC_COUNT; CMP RG1 RG3; JEQ >UnA.Done
	
		/ Check if matching SemAdd (if not, loop)
		LOD RG3 RG1 >ProcSemAdds; CMP RG3 RG0; JNE >UnA.Loop
		
		/ If matching, unset WAITs in the support word.
		LOD OUT RG1 >SupportList
		ALI UST OUT >SUP_WAIT_BIT; ALI UST OUT >SUP_IO_WAIT_BIT
		
		/ Then check if SemAdd is in the OS semaphores.
		AIN SET OUT >SUP_OS_WAIT_BIT; JIF NCR >UnA.NotOS
			/ If in the OS, decrement SoftBlockCount
			ZRO RG3; LOD RG3 RG3 >SoftBlockCount
			DEC RG3; STR RG3 RG3 >SoftBlockCount
			
			/ And unset OS_WAIT in the support word.
			ALI UST OUT >SUP_OS_WAIT_BIT
		#UnA.NotOS
		
		/ Update the support word
		STR OUT RG1 >SupportList
	
		/ Set proc's SemAdd & SemNo to 0
		ZRO RG3; STR RG3 RG1 >ProcSemAdds; STR RG3 RG1 >ProcSemNos
		
		/ Count++ and loop
		INC RG2; JMP >UnA.Loop
	#UnA.Done
	
	/ Do [SemAdd] += count and return.
	LOD RG1 RG0 0; ALU ADD RG1 RG2; STR RG1 RG0 0
	RET
}



/ Loads the program file at IOP into memory. Returns HLB, NULL if no space, or 0 no file.
/ Does not create the thread for said program, but does basically everything else.
/ Modifies RG0-5, and FLG
#LoadProgramTSFS  %FileNum w/ IOP > NewHLB|NULL|0% = {

	PSH 3; STR RA SP 0
	
	
	% Unused drive format check code:
	
	/ First, check if it's TSFS (These checks really don't take much time thanks to how IO is handled)
	
	/ Quick "parity check"
	MOV RG2 IO; AIN MOD RG2 >TSFS_ENTRY_SIZE; JIF NEZ >LPT.TSFSError
	
	/ Longer, "zero check"
	#LPT.ZLoop
		/ Get the pointer to the end of the drive.
		ALI SUB RG2 >TSFS_ENTRY_SIZE
		ALI SET FLG >DRIVE_PTR_BIT; MOV IO RG2; ALI UST FLG >DRIVE_PTR_BIT
		MOV RG1 IO; PAS RG1; JIF EQZ >LPT.ZLoop
	/ Got the address for end of memory.
	MOV RG2 RG1
	
	/ Just make sure this actually is the pointer.
	PAS IO; JIF NEZ >LPT.TSFSError
	
	/ Now check to see if it's (probably) the end of memory.
	ALI SET FLG >DRIVE_PTR_BIT; MOV IO RG2; ALI UST FLG >DRIVE_PTR_BIT
	PAS IO; JIF NEZ >LPT.TSFSError
	%
	
	
	/ Check if the given file number actually exists (within the index)
	ALI MUL RG0 >TSFS_ENTRY_SIZE
	ZRO RG1; ALI SET FLG >DRIVE_PTR_BIT; MOV IO RG1; ALI UST FLG >DRIVE_PTR_BIT
	MOV RG1 IO; CMP RG0 RG1; JGE >LPT.FileError
	
	/ Check if the file is empty
	ALI SET FLG >DRIVE_PTR_BIT; MOV IO RG0; ALI UST FLG >DRIVE_PTR_BIT
	MOV RG0 IO; PAS IO; JIF EQZ >LPT.FileError
	
	/ Tell LoadProgLoadable where to load this file.
	STR RG0 SP 1; JMP >LPL.LPTSkip
	
	
	#LPT.FileError
	ZRO OUT; POP 3; RET
}

/ LPT, but for .tload drives
#LoadProgLoadable  %w/ IOP > NewHLB|NULL% = {

	PSH 3; STR RA SP 0; ZRO RG0; STR RG0 SP 1
	#LPL.LPTSkip  / LPL has already done the above instructions
	STR SF0 SP 2
	
	/ Calculate the size of the program in RG0 & SF0 (in chunks)
	ALI SET FLG >DRIVE_PTR_BIT; MOV IO RG0; ALI UST FLG >DRIVE_PTR_BIT
	MOV RG0 IO
	LDI RG1 >CHUNK_SIZE; ALU DIV RG0 RG1; ALI ADD RG0 2
	MOV SF0 RG0
	
	/ Check memory to see where it will fit
	CAL >FindOpenMemory  / = FirstChunk
	AIN ADD OUT 1; JIF CAR >LPL.Error
	
	/ Calculate HLB then do MarkBits(FirstChunk, Size)
	MOV RG1 SF0; MOV RG0 OUT; MOV SF0 RG0
	
	LDI RG2 >CHUNK_SIZE; ALU MUL OUT RG2; ALI SRB OUT >LO_SHIFT
	MOV RG3 RG1; ALU MUL RG3 RG2; ALU OR OUT RG3
	CAL >MarkBits

	/ Load program into memory using LoadFile(CHUNK_SIZE * FirstChunk, Size)
	LOD RG1 SP 1
	LDI RG2 >CHUNK_SIZE; ALU MUL SF0 RG2; MOV RG0 SF0
	ALI SET FLG >DRIVE_PTR_BIT; MOV IO RG1; ALI UST FLG >DRIVE_PTR_BIT; MOV RG1 IO
	
	LOD RA SP 0; LOD SF0 SP 2
	POP 3
	
	JMP >LoadFile	/ This is the last function call, so return from LoadFile to RA
	
	/ Unless there was an error, then return NULL
	#LPL.Error
	NUL OUT; LOD RA SP 0; LOD SF0 SP 2
	POP 3
	RET
}



/ ----------------------------------------------Helper Functions----------------------------------------------



/ Won't return, and will instead goto SRH.UserPriv, if the current proc is accessing protected devices and is user.
#CheckIOPAccess  %None > IOP | no return% = {
	/ Get the proc's FLG (in RG0)
	ZRO RG0; LOD RG0 RG0 >CurrentStatePtr; LOD RG0 RG0 >FLG_OFFSET
	
	/ Check if the proc is kernel (meaning we can skip checks)
	AIN SET RG0 >UE_PU_SHIFT; JIF NCR >CIA.IsKernel
		/ If it's user, first make sure it's not accessing DevNo 0
		LDI RG1 >IOP_DEVICE_MASK
		AFN AND RG0 RG1; JIF EQZ >SRH.UserPriv
		
		/ Now make sure it's not accessing protected device groups
		ALI SRB RG0 >IOP_SHIFT
		LDI RG1 >MAX_UNPROT_IOP_NUM; CMP RG1 RG0; JLT >SRH.UserPriv
		JMP >CIA.Done
		
	#CIA.IsKernel
		/ If kernel, just get IOP num in RG0
		ALI SRB RG0 >IOP_SHIFT
		
	#CIA.Done
	/ Now return the IOP number
	MOV OUT RG0
	RET
}



/ Checks the given relative address from the current process to see if it is OOB or in the OS.
#CheckCurProcAddress  %RelAddr > Addr | no return% = {	
	/ Get FLG (RG3) and HLB (RG2)
	ZRO RG2; LOD RG2 RG2 >CurrentStatePtr
	LOD RG3 RG2 >FLG_OFFSET
	LOD RG2 RG2 >HLB_OFFSET
	
	/ Check for Kernel
	AIN SET RG3 >UE_PU_SHIFT; JIF NCR >CPA.IsKernel
		/ If not kernel, check for OOB using HI (RG3) (This is the only way they can OOB)
		MOV RG3 RG2; LDI RG1 >HI_MASK; ALU AND RG3 RG1
		MOV RG1 RG0
		ALI SRB RG1 1; ALI SRB RG3 1
		CMP RG1 RG3; JGE >SRH.UserOOB
		
		/ Finally, get the real address in OUT and return
		ALI SLB RG2 >LO_SHIFT; ALU ADD RG2 RG0; MOV OUT RG2
		JMP >CPA.Done
		
	#CPA.IsKernel
		/ If Kernel, get the real address in OUT
		ALI SLB RG2 >LO_SHIFT; ALU ADD RG2 RG0; MOV OUT RG2
		
		/ Check for OSMod
		ALI SRB RG2 1
		LDI RG3 >OSEndPoint; INC RG3; ALI SRB RG3 1  / INC here just to make sure there are no shift issues.
		CMP RG2 RG1; JLT >SRH.OSMod
		
		/ If not, return.
	#CPA.Done
	RET
}



/ Calls terminate on the current process then returns to the dispatcher
#TerminateCurrent  %!Fn% = {
	ZRO RG0; LOD RG0 RG0 >CurrentProcID
	LDI RA >Dispatcher; JMP >Terminate
}



/ Syscall return codes handler.
/ Meant to be treated as a collection of mini subroutines.
/ IMPORTANT: YOU DO NOT NEED TO WORRY ABOUT MISALIGNED SP WHEN JUMPING HERE!
#SysReturnHandler  %!Fn% = {
	/ The operation was successful. Resume the process
	#SRH.Success
	LDI RG0 >SYS_SUCCESSFUL
	ZRO RG1; LOD RG1 RG1 >CurrentStatePtr
	STR RG0 RG1 >OUT_REG_NUM
	JMP >ResumeProc
	
	/ Sometimes we want to skip the process, even if the operation was successful.
	#SRH.SuccessSkip
	LDI RG0 >SYS_SUCCESSFUL; JMP >SRH.FinSkip
	
	/ For all errors we skip the process.
	
	/ There is no room for another proc.
	#SRH.MaxProcs
	LDI RG0 >SYS_MAX_PROCS; JMP >SRH.FinSkip
	
	/ There is not enough room in memory.
	#SRH.OutOfMem
	LDI RG0 >SYS_OUT_OF_MEM; JMP >SRH.FinSkip
	
	/ The file in question is missing.
	#SRH.MissingFile
	LDI RG0 >SYS_MISSING_FILE; JMP >SRH.FinSkip
	
	/ IOP was not set correctly for this operation.
	#SRH.IOPError
	LDI RG0 >SYS_BAD_IOP; JMP >SRH.FinSkip
	
	/ The user process attempted to work with addresses out-of-bounds.
	#SRH.UserOOB
	LDI RG0 >SYS_ATTEMPTED_OOB; JMP >SRH.FinSkip
	
	/ The user process attempted a privileged operation.
	#SRH.UserPriv
	LDI RG0 >SYS_ATTEMPTED_PRIV; JMP >SRH.FinSkip
	
	/ The process attempted to alter/access the OS directly.
	#SRH.OSMod
	LDI RG0 >SYS_ATTEMPTED_OS; JMP >SRH.FinSkip
	
	/ Write the error code in RG0 and skip the process
	#SRH.FinSkip
	ZRO RG1; LOD RG1 RG1 >CurrentStatePtr
	STR RG0 RG1 >OUT_REG_NUM
	JMP >Dispatcher
}



/ Waits for an interrupt.
/ If the specified time passes (WAIT_TIME), then run dispatcher again, else jump to ExH.Skip to handle it.
#WaitForInt  %!Fn% = {	
	/ The only possible interrupts are TICK, PAUS, STOP, and CTDZ.
	
	/ Store off CTD, EPC & FLG's U/E stack
	MOV RG0 CTD
	MOV RG1 FLG; ALI AND RG1 >UE_STACK_MASK
	MOV RG2 EPC
	
	/ Setup registers for waiting.
	LDI EXA >WFI.Done; LDI CTD >WAIT_TIME; ALI SET FLG >UE_CE_BIT
	
	/ Wait...
	#WFI.Wait: JMP >WFI.Wait
	
	/ Now reset registers (Note: UE stack is 0000 here).
	#WFI.Done
	ALU OR FLG RG1
	MOV EPC RG2
	LDI EXA >ExHandler
	
	/ If it's CTDZ, do another set of dispatcher loops.
	PAS CTD; JIF EQZ >Dispatcher
	
	/ Else, let the exception handler handle it
	MOV CTD RG0; JMP >ExH.Skip
}



/ --------------------------------------------------Syscalls--------------------------------------------------



/ Syscall handler.
#SysHandler  %!Fn% = {
	/ Get the proc's RG1, RG2, RG3, & RG0 in RG0, RG1, RG2, & RG3 respectively (for convenience)
	ZRO SF0; LOD SF0 SF0 >CurrentStatePtr
	LOD RG0 SF0 1; LOD RG1 SF0 2; LOD RG2 SF0 3; LOD RG3 SF0 0
	
	/ Check which syscode it is.
	CMI RG3 >SYSCODE_GIVE_UP_TURN; JEQ >Dispatcher
	
	CMI RG3 >SYSCODE_LOAD_PROGRAM; JEQ >SysLoadProg
	
	CMI RG3 >SYSCODE_MAKE_THREAD; JEQ >SysSpawnThread
	
	CMI RG3 >SYSCODE_TERMINATE; JEQ >TerminateCurrent
	
	CMI RG3 >SYSCODE_VERHOGEN; JEQ >SysVerhogen
	
	CMI RG3 >SYSCODE_PASSEREN; JEQ >SysPasseren
	
	CMI RG3 >SYSCODE_IO_MUTEX; JEQ >SysIOMutex
	
	CMI RG3 >SYSCODE_IO_RELEASE; JEQ >SysIORelease
	
	CMI RG3 >SYSCODE_WAIT_TICK; JEQ >SysWaitTick
	
	CMI RG3 >SYSCODE_IO_WAIT_READ; JEQ >SysWaitRead
	
	CMI RG3 >SYSCODE_IO_WAIT_WRITE; JEQ >SysWaitWrite
	
	/ Else, return SYSCODE_ERROR
	LDI RG0 >UNKNOWN_SYSCODE_ERROR; STR RG0 SF0 6; JMP >ResumeProc
}



/ Spawns a thread given the PC & SP, and whether the thread should be kernel.
/ Note: We are jumping to SysReturnHandler no matter what, so no need to worry about SP.
#SysSpawnThread  %PC, SP, IsKernel? > !Fn% = {
	/ Store the arguments for later use.
	PSH 3; STR RG0 SP 0; STR RG1 SP 1; STR RG2 SP 2
	
	/ Make sure that there is room for the thread
	ZRO RG3; LOD RG3 RG3 >ProcCount
	LDI SF0 >MAX_PROC_COUNT; CMP RG3 SF0; JEQ >SRH.MaxProcs
	
	/ If current proc is user, check to make sure PC, SP, and IsKernel are acceptable.
	/ Use the new CheckCurProcAddress
	
	/ First, check IsKernel
	ZRO RG3; LOD RG3 RG3 >CurrentStatePtr; LOD RG3 RG3 >FLG_OFFSET
	AIN SET RG3 >UE_PU_SHIFT; JIF NCR >SST.Kernel
		/ If not kernel, make sure IsKernel is 0
		PAS RG2; JIF NEZ >SRH.UserPriv
	#SST.Kernel
	
	/ Now check PC and SP (by swapping RG0 and RG1)
	MOV SF0 RG0; MOV SF1 RG1
	CAL >CheckCurProcAddress
	MOV RG0 SF1; MOV RG1 SF0
	CAL >CheckCurProcAddress
	
	/ Check if this should be a user or kernel proc.
	LOD RG2 SP 2; PAS RG2; JIF EQZ >SST.SpawnU
		/ Spawning a kernel process.
		LDI FLG >KERNEL_PROC_FLG; JMP >SST.Skip
	#SST.SpawnU
		/ Spawning a user process.
		LDI FLG >USER_PROC_FLG
	#SST.Skip
	
	/ Call MakeChildThread with HLB and FLG, get ProcNum from it.
	ZRO RG0; LOD RG0 RG0 >CurrentStatePtr; LOD RG0 RG0 >HLB_OFFSET
	CAL >MakeChildThread
	
	/ Use ProcNum to get the pointer to its state.
	LDI RG0 >NUM_STATE_REGS; ALU MUL RG0 OUT
	LDI RG1 >StateList; ALU ADD RG0 RG1
	
	/ Now set EPC and SP.
	LOD RG1 SP 0; STR RG1 RG0 >EPC_OFFSET
	LOD RG1 SP 1; STR RG1 RG0 >SP_OFFSET
	
	/ Finally, set its IS_THREAD support bit
	LOD RG1 OUT >SupportList; ALI SET RG1 >SUP_IS_THREAD_BIT; STR RG1 OUT >SupportList
	
	/ Resume current process.
	JMP >SRH.Success
}



/ Loads the program, makes it a child thread, then resumes the current process, setting OUT accordingly.
/ Note: We are jumping to SysReturnHandler no matter what, so no need to worry about SP.
#SysLoadProg  %FileNumber, IsKernel? > !Fn% = {
	MOV SF0 RG1
	
	/ Before doing anything, make sure we can actually spawn a process
	ZRO RG1; LOD RG1 RG1 >ProcCount; LDI RG2 >MAX_PROC_COUNT
	CMP RG1 RG2; JGE >SRH.MaxProcs
	
	/ Get FLG and make sure pUser is set to 0
	ZRO RG1; LOD RG1 RG1 >CurrentStatePtr; LOD RG2 RG1 >FLG_OFFSET
	AIN SET RG2 >UE_PU_SHIFT; JIF CAR >SRH.UserPriv
	
	/ Check if FLG is configured properly
	LDI RG1 >IOP_GROUP_MASK; ALU AND RG1 RG2; ALI SRB RG1 >IOP_GROUP_SHIFT
	CMI RG1 >DRIVE_IOP_GROUP; JNE >SRH.IOPError
	
	/ Check which load function we're calling, set FLG then jump
	MOV FLG RG2; LDI RA >SLP.Ret
	AIN ADD RG0 1; JIF EQZ >LoadProgLoadable
		JMP >LoadProgramTSFS
	#SLP.Ret
	
	/ Check for loading errors
	AIN ADD OUT 1; JIF CAR >SRH.OutOfMem
	PAS OUT; JIF EQZ >SRH.MissingFile
	
	/ Figure out what privilege level to spawn child proc at.
	MOV RG0 SF0; PAS RG0; JIF EQZ >SLP.ChildUser
		LDI FLG >KERNEL_PROC_FLG; JMP >SLP.ChildUSkip
	#SLP.ChildUser
		LDI FLG >USER_PROC_FLG
	#SLP.ChildUSkip
	
	/ Now spawn the thread
	MOV RG0 OUT; LDI RA >SRH.Success; JMP >MakeChildThread
}



/ The Passeren syscall. Does all the checks to make sure syscall is valid.
#SysPasseren  %RelSemAdd > !Fn% = {
	/ Make sure the given address is OK to Passeren.
	CAL >CheckCurProcAddress
	
	/ Now call Passeren with the given address.
	MOV RG0 OUT; ZRO RG1; LOD RG1 RG1 >CurrentProcID
	CAL >Passeren
	
	/ Depending on the result, either resume the process or skip the remainder of its burst.
	PAS OUT; JIF EQZ >SRH.Success
		JMP >SRH.SuccessSkip
}



/ The Verhogen syscall. Does all the checks to make sure syscall is valid.
#SysVerhogen  %RelSemAdd > !Fn% = {
	/ Make sure the given address is OK to Verhogen.
	CAL >CheckCurProcAddress
	
	/ Then call Verhogen using the given address and resume the process
	MOV RG0 OUT
	LDI RA >SRH.Success; JMP >Verhogen
}



/ Does Passeren on the given I/O's mutex. Does checks to make sure it's valid.
#SysIOMutex  %!Fn% = {
	/ Make sure the proc's IOP is OK.
	CAL >CheckIOPAccess
	
	/ Call Passeren.
	MOV RG0 OUT; LDI RG1 >IOMutexSems; ALU ADD RG0 RG1
	ZRO RG1; LOD RG1 RG1 >CurrentProcID
	CAL >Passeren
	
	/ Check if we should resume the proc or not.
	PAS OUT; JIF EQZ >SRH.Success
		JMP >SRH.SuccessSkip
}



/ Does Verhogen on the given I/O's mutex. Does checks to make sure it's valid.
#SysIORelease  %!Fn% = {
	/ Make sure the proc's IOP is OK.
	CAL >CheckIOPAccess
	
	/ Call Verhogen.
	MOV RG0 OUT; LDI RG1 >IOMutexSems; ALU ADD RG0 RG1
	LDI RA >SRH.Success; JMP >Verhogen
}



/ Passeren the WaitTick semaphore
#SysWaitTick  %!Fn% = {
	/ Do Passeren(TickWaitSem, CurrentProcID) and skip the remainder of the proc's burst.
	LDI RG0 >TickWaitSem
	ZRO RG1; LOD RG1 RG1 >CurrentProcID
	LDI RA >SRH.SuccessSkip; JMP >Passeren
}



/ Current proc wants to wait for the given IOR signal.
#SysWaitRead  %!Fn% = {
	/ First, check for privileged I/O and get IOP
	CAL >CheckIOPAccess
	
	/ Now, check if the device is already reading
	JIF PRD >SRH.Success
	
	/ If not, set set the current proc's (RG0) support word (RG1) correctly
	ZRO RG0; LOD RG0 RG0 >CurrentProcID; LOD RG1 RG0 >SupportList
	ALI SET RG1 >SUP_IO_WAIT_BIT; ALI UST RG1 >SUP_IO_TYPE_BIT
	STR RG1 RG0 >SupportList
	
	/ Setup RG1 for Passeren call
	MOV RG1 RG0
	
	/ And place the current proc on its waitlist
	LDI RG0 >IOReadSems; ALU ADD RG0 OUT
	LDI RA >SRH.SuccessSkip; JMP >Passeren
}



/ Current proc wants to wait for the given IOW signal.
#SysWaitWrite  %!Fn% = {
	/ First, check for privileged I/O and get IOP
	CAL >CheckIOPAccess
	
	/ Now, check if the device is already writing
	JIF PWT >SRH.Success
	
	/ If not, set set the current proc's (RG0) support word (RG1) correctly
	ZRO RG0; LOD RG0 RG0 >CurrentProcID; LOD RG1 RG0 >SupportList
	ALI SET RG1 >SUP_IO_WAIT_BIT; ALI SET RG1 >SUP_IO_TYPE_BIT
	STR RG1 RG0 >SupportList
	
	/ Setup RG1 for Passeren call
	MOV RG1 RG0
	
	/ And place the current proc on its waitlist
	LDI RG0 >IOWriteSems; ALU ADD RG0 OUT
	LDI RA >SRH.SuccessSkip; JMP >Passeren
}



/ The end of the OS's code segment in memory
#OSEndPoint
