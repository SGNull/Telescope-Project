JMP >Init
(%
  This is a preliminary test of the Telescope Computing System
  It will test:
		Drive 0
		Terminal/Keyboard 0
		GPIO 0
		TNET 0
		Immutables
		
  Here is what the test will do:
		Computer code 1 will be written immediately
		The cycles counter will be started
		
		Drive: Needs to start with the words 0, 1, 2, 3 in order
		Drive pointer will have 1 written to it, and will then be read to confirm
		Drive will then be read from sequentially 3 times
		
		Keyboard: Type in 'abc'
		Terminal will output 1,2,3
		
		GPIO will be tested for kernel privleges (just to make sure that device 0 protection works)
		GPIO should have a register configured to be written to and read from the CPU
		GPIO will have 4 written to it, and 4 read from it.
		
		TNET should have the accompanying TestServe program running on a seperate computer
		This computer will write a 1 to TNET, then wait for a 2 from the other
		It will immediately check to see if the read bit is off.
		The other computer should begin with a status code 1, write the 2, then halt with the code 2
		
		Two sequential reads will happen on the lower word to make sure the cycle counter is running.
		Now the cycles counter will be stopped
		Two sequential reads will happen on the lower word to make sure it stopped
		Many cycles have passed, so it will check to see if the lower word is over 20 (arbitrary average sized number)
		The cycle counter should be rather small, though, so the upper word should be 0
		Now 2 random numbers will be read to check if they're different
		
		Finally, the test will halt with code 2.
%)



(/ -------------------------Data Segment----------------------
@START_CODE = 1
@STOP_CODE = 2

@DRIVE_ERROR = 0xF001
@DRIVE_PTR_ERROR = 0xF002
@KEY_TERM_ERROR = 0xF003
@GPIO_ERROR = 0xF004
@TNET_ERROR = 0xF005
@CYCLE_COUNT_ERROR = 0xF006
@RAND_ERROR = 0xF007


@MIN_CYCLE = 20

@DRIVE_FLG = 0x0000
#DriveWords = 1, 2, 3

@DRIVE_PTR_FLG = 0x2000
@DRIVE_LOC = 1

@KEY_TERM_FLG = 0x4000
#KeyboardIn = 'a', 'b', 'c'
#TerminalOut = "123"

@GPIO_FLG = 0x6000
@GPIO_NUM = 0x23

@TNET_FLG = 0x8000
@TNET_SEND = 1
@TNET_RECEIVE = 2

@CYCLE_LOWER_START_FLG = 0xE000
@CYCLE_UPPER_STOP_FLG = 0xE800
@RAND_STATUS_FLG = 0xF000
) 



/ -------------------------Code Segment----------------------
#Init
#DriveCheck
	/ Set start code
	LDI FLG >RAND_STATUS_FLG; LDI IO >START_CODE
	
	/ Start cycle counter (the data written does not matter)
	LDI FLG >CYCLE_LOWER_START_FLG; MOV IO RG0
	
	/ Check drive pointer for read/write
	LDI RG0 >DRIVE_LOC; LDI FLG >DRIVE_PTR_FLG; MOV IO RG0
	MOV RG1 IO; CMP RG1 RG0; JNE >DrivePTRError
	
	/ Grab the data from the drive
	LDI FLG >DRIVE_FLG
	MOV RG0 IO; MOV RG1 IO; MOV RG2 IO
	
	/ Make sure the pointer worked
	LDI FLG >DRIVE_PTR_FLG; MOV RG3 IO
	LDI RG4 >DRIVE_LOC
	ALU SUB RG3 RG4
	AIN SUB RG3 3; JNE >DrivePTRError
	
	/ Check that the data is correct
	LDI RG3 0
	LOD RG4 RG3 >DriveWords
	CMP RG0 RG4; JNE >DriveError
	
	INC RG3; LOD RG4 RG3 >DriveWords
	CMP RG1 RG4; JNE >DriveError
	
	INC RG3; LOD RG4 RG3 >DriveWords
	CMP RG2 RG4; JNE >DriveError
	
	/ We're done, so jump to the next test
	JMP >Keyboard&Terminal
	
#Keyboard&Terminal
	
	
#DrivePTRError
	LDI FLG >RAND_STATUS_FLG
	LDI IO >DRIVE_PTR_ERROR
	HLT
	
#DriveError
	LDI FLG >RAND_STATUS_FLG
	LDI IO >DRIVE_ERROR
	HLT








	
