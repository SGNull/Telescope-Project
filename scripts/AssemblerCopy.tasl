JIF TRU >StartPoint

(/ Constants, variables, and tables.
@INFLG = 0
@OUTFLG = 0x800

@TABLESTOP = 0xFFFF

/ Instruction table entries: (mnemonic_hash, translation, operand_bitmap)
(#InstTable = [0xd188, 0x0, 0b0000,  / HLT
               0xb672, 0x1, 0b0000,  / RSM
               0xcf33, 0x2, 0b0000,  / SYS
               0xd9ed, 0x3, 0b0011,  / MOV
               0x992a, 0x4, 0b0100,  / JIF
               0xa48c, 0x5, 0b0010,  / LDI
               0x91ec, 0x6, 0b0011,  / LOD
               0xca93, 0x7, 0b0011,  / STR
               0xd581, 0x8, 0b0111,  / ALU
               0xa581, 0x9, 0b1111,  / ALI
               0x9981, 0xA, 0b0111,  / ALF
               0x9921, 0xB, 0b1111,  / AIF
               0xb981, 0xC, 0b0111,  / ALN
               0xb921, 0xD, 0b1111,  / AIN
               >TABLESTOP
               ])

/ Register table entries: (mnemonic_hash, translation)
(#RegTable = [0x40F2, 0x0,  / RG0
			  0x44F2, 0x1,  / RG1
			  0x48F2, 0x2,  / RG2
			  0x4CF2, 0x3,  / RG3
			  0x50F2, 0x4,  / RG4
			  0x54F2, 0x5,  / RG5
			  0x58F2, 0x6,  / RG6
			  0x5CF2, 0x7,  / RG7
			  0x0070, 0x8,  / PC
			  0x01E9, 0x9,  / IO
			  0x9D86, 0xA,  / FLG
			  0x0213, 0xB,  / SP
			  0x8988, 0xC,  / HLB
			  0x9283, 0xD,  / CTD
			  0x8E05, 0xE,  / EPC
			  0x8705, 0xF,  / EXA
			  >TABLESTOP
			  ])

/ Modifier table entries: (mnemonic_hash, translation)
(#ModTable = [0xD1EE, 0x0,  / NOT
			  0x91C1, 0x1,  / AND
			  0x024F, 0x2,  / OR
			  0xC9F8, 0x3,  / XOR
			  0x8993, 0x4,  / SLB
			  0x8A53, 0x5,  / SRB
			  0xB0B3, 0x6,  / SEL
			  0x8DC5, 0x7,  / ENC
			  0x9CAE, 0x8,  / NEG
			  0x9081, 0x9,  / ADD
			  0x8C81, 0xA,  / ADC
			  0x8AB3, 0xB,  / SUB
			  0x8853, 0xC,  / SBB
			  0xB2AD, 0xD,  / MUL
			  0xD924, 0xE,  / DIV
			  0x91ED, 0xF,  / MOD

			  0xEA25, 0x0,  / EQZ
			  0xEA8c, 0x1,  / LTZ
			  0xC823, 0x2,  / CAR
			  0xCACF, 0x3,  / OVR
			  0x9250, 0x4,  / PRD
			  0xD2F0, 0x5,  / PWT
			  0xD654, 0x6,  / TRU
			  0x91D2, 0x7,  / RND
			  0xE8AE, 0x8,  / NEZ
			  0xE8A7, 0x9,  / GEZ
			  0xC86E, 0xA,  / NCR
			  0xD9EE, 0xB,  / NOV
			  0xC9D0, 0xC,  / PNR
			  0xDDD0, 0xD,  / PNW
			  >TABLESTOP
			  ])

/ It looks strange, but SkipChars includes newline and tab.
(#SkipChars = ['
', '	', '(', ')', ' ', ',' '=', ':', '[', ']', >TABLESTOP])

@COMMENT = '/'
@NEWLINE = '
'
@COMMAND = '%'
@LABEL = '#'
@CONST = '@'
@HEX = 'x'
@BIN = 'b'
@REF = '>'
@CHAR = ''' /' /To make the Notepad++ UDL not do weird things, /' was used here.
@ARRAY = '~'
@STOP = 0


#Buffer: [~64] / Buffer is input_heap
#BuffIdx = 0 / BuffIdx is input_heap_pointer

#LblTblIdx = 0 / LblTblIdx is table_heap_pointer

)

(#StartPoint  / Not a function, so do nothing with the stack
	
	/ Write 0 to the input
	LDI RG0 >INFLG
	MOV FLG RG0
	ALU AND RG0 0
	MOV FLG RG0
	
	/ Goto BuildTables
	JIF TRU >BuildTables
)

(#GetValueBase  / UNSAFE for RG1-3, RG0:multiplier, RG1:startIndex, RG6:output, RG7:returnAdd
	/ RG1 = index
	/ RG2 = input_heap_pointer
	/ RG3 = next_char
	/ RG6 = out
	/ RG7 = return address
	
	LOD RG2 RG2 >BuffIdx
	AIF AND RG6 0
	
	#GVB.Loop
		ALN SUB RG1 RG2
		JIF EQZ >GVB.Done
		
		LOD RG3 RG1 >Buffer
		AIN SEL RG3 5
		JIF EQZ >GVB.Skip
			AIF ADD RG3 9
			
		#GVB.Skip
		AIF AND RG3 0xF
		ALF MUL RG6 RG0
		ALF ADD RG6 RG3
		
		AIF ADD RG1 1
		
		
	#GVB.Done

	MOV PC RG7
)

(#GetNumericValue  / UNSAFE for RG0-1, RG6:output, RG7:returnAdd
	/ RG0 = second_char
	/ RG1 = input_heap & HEX_CHAR & BIN_CHAR
	
	/Passes control straight to GetValueBase
	
	LOD RG1 RG1 >Buffer
	LOD RG0 RG1 1
	
	ALN SEL RG0 5
	JIF NEZ >GNV.1
		LDI RG0 10
		AIF AND RG0 0
		JIF TRU >GetValueBase
		
	#GNV.1
	LDI RG1 >HEX_CHAR
	ALN SUB RG0 RG1
	JIF NEZ >GNV.2
		LDI RG0 16
		LDI RG1 2
		JIF TRU >GetValueBase
		
	#GNV.2
	LDI RG1 >BIN_CHAR
	ALN SUB RG0 RG1
	JIF NEZ GNV.3
		LDI RG0 2
		LDI RG1 2
		JIF TRU >GetValueBase
		
	#GNV.3
	HLT
	0xFFF0
	JIF TRU >StartPoint
)

(#LabelLookup  / UNSAFE for ALL, RG6:output, RG7:returnAdd
	/ RG0 = table_index
	/ RG1 = table_heap_pointer
	/ RG2 = size
	/ RG3 = input_heap_pointer
	/ RG4 = loop_index
	/ RG5 = temp
	
	AIF AND RG0 0
	LOD RG1 RG1 >LblTblIdx
	
	#LL.MainLoop
		/ Check if we're out of labels to search through.
		ALN SUB RG0 RG1
		JIF LTZ >LL.MS1
			HLT /exit(1)
			0xFFF1 / print("LABEL NOT FOUND ERROR")
			JIF TRU >StartPoint
		
		#LL.MS1
		/ Check if the label is the right size.
		LOD RG2 RG0 >LabelTable
		ALN SUB RG3 RG2
		JIF NEZ >LL.MS2
			LDI RG4 1
			
			/ Loop through both the input_heap string and the table's string at the same time.
			#LL.SubLoop
				/ If we reach the end of the heap, we have a match (cause they're the same size strings)
				ALN SUB RG4 RG3
				JIF NEZ >LL.SS
					ALF ADD RG0 RG2
					LOD RG6 RG0 >LabelTable
					JIF TRU >LL.Done
				
				/ If any pair of characters don't match, exit the loop.
				#LL.SS
				MOV RG5 RG0
				ALF ADD RG5 RG4
				LOD RG5 RG4 >LabelTable
				LOD RG6 RG4 >Buffer
				ALN SUB RG5 RG6
				JIF NEZ >LL.MS2 / break
				
				AIF ADD RG4 1
				JIF TRU >LL.SubLoop
				
				
		#LL.MS2
		ALF ADD RG0 RG2
		AIF ADD RG0 1
		JIF TRU >LL.MainLoop
	
	#LL.Done
	MOV PC RG7
)

(#TblIdxLookup  / UNSAFE for RG3-5, RG0:key, RG1:table, RG2:entry_size, RG6:output, RG7:returnAdd
	/ RG3 = index
	/ RG4 = next_entry_key
	/ RG5 = TABLESTOP
	AIF AND RG3 0
	LDI RG5 >TABLESTOP
	#TIL.Loop
		STR RG3 RG3 >TIL.SMC
		LOD RG4 RG1 #TIL.SMC[0]
		
		ALN SUB RG4 RG0
		JIF NEZ TIL.Next
			MOV RG6 RG3
			JIF TRU TIL.End
		
		ALN SUB RG4 RG5
		JIF NEZ TIL.Next2
			MOV RG6 RG5
			JIF TRU TIL.End
		
		#TIL.Next2
		ALF ADD RG3 RG2
		JIF TRU TIL.Loop
			
	#TIL.End
	MOV PC RG7
)

(#GotoChar  / UNSAFE for RG5-6, RG0:target, RG7:returnAdd
	/ RG5 = char
	/ RG6 = STOP_CHAR
	LDI RG6 >STOP
	#GC.Loop
		MOV RG5 IO
		ALN SUB RG5 RG0
		JIF EQZ >GC.Done
		ALN SUB RG5 RG6
		JIF NEZ >GC.Loop
	#GC.Done
	MOV PC RG7
)

(#GetNext  / UNSAFE for ALL, RG7:returnAdd
	/ RG0: Reserved for goto_char input
	/ RG1 = char
	/ RG2 = COMMAND_CHAR
	/ RG3 = COMMENT_CHAR
	ALI SUB SP 1
	STR RG7 SP 0
	
	LDI RG2 >COMMAND
	LDI RG3 >COMMENT
	LDI RG7 >GN.Loop1  / Function calls will use this as the return address by default.
	
	/ "Look for the start of a viable sequence"
	#GN.Loop1
		MOV RG1 IO
		ALN SUB RG1 RG2
		JIF NEZ >GN.L1
			MOV RG0 RG2
			JIF TRU >GotoChar
		
		#GN.L1
		ALN SUB RG1 RG3
		JIF NEZ >GN.L2
			LDI RG0 >NEWLINE
			JIF TRU >GotoChar
		
		#GN.L2  / "if char is not a skip character"
			MOV RG0 RG1
			LDI RG1 >SkipChars
			LDI RG2 1
			LDI RG7 >GN.Ret1
			JIF TRU >TblIdxLookup #GN.Ret1
			
			AIN ADD RG6 1  / Check if not NULL
			JIF NCR >GetNext  / Reload the register values if skippable.
			
	/ Now:
	/ RG0 = char
	/ RG1 = constants (STOP, COMMENT, COMMAND, etc.)
	/ RG2 = 1 (for table_index_lookup)
	/ RG4 = input_heap_pointer (BufferIdx)
	LDI RG1 >STOP
	
	/ "If we hit a stop character, just put that in the input heap"
	ALN SUB RG0 RG1
	JIF NEZ >GN.Skip1
		STR RG0 RG0 >Buffer
		LDI RG4 1
		JIF TRU >GN.Done
	#GN.Skip1
	
	ALI AND RG4 0
	LDI RG2 1
	
	/ "Else, get the rest of the character sequence"
	#GN.Loop2
		STR RG0 RG4 >Buffer
		ALI ADD RG4 1
		
		MOV RG0 IO
		
		LDI RG1 >COMMAND
		ALN SUB RG0 RG1
		JIF NEZ >GN.LL1
			LDI RG7 >GN.Loop2D
			JIF TRU >GotoChar
		
		#GN.LL1
		LDI RG1 >COMMENT
		ALN SUB RG0 RG1
		JIF NEZ >GN.LL2
			LDI RG0 >NEWLINE
			LDI RG7 >GN.Loop2D
			JIF TRU >GotoChar
		
		#GN.LL2
		LDI RG1 >STOP
		ALN SUB RG0 RG1
		JIF NEZ >GN.LL3
			JIF TRU >GN.Loop2D
		
		#GN.LL3  / "if char is a skip character"
			LDI RG1 >SkipChars
			
			/ Preserving RG4 (TblIdxLookup is UNSAFE for that register)
			ALI SUB SP 1
			STR RG4 SP 0
			LDI RG7 >GN.LLRet
			JIF TRU >TblIdxLookup #GN.LLRet
			LOD RG4 SP 0
			ALI ADD SP 1
			
			ALN ADD RG6 1
			JIF CAR >GN.Loop2
	#GN.Loop2D
	
	/ RG0 = input_heap[0] & char
	/ RG1 = CHAR_CHAR & input_heap (Buffer)
	/ RG4 = input_heap_pointer (BufferIdx)
	
	/ "Check to see if we tried to read a character that was a skip or character character"
	LOD RG0 RG0 >Buffer
	LDI RG1 >CHAR
	ALN SUB RG0 RG1
	JIF NEZ >GN.Done
	
		LDI RG1 >Buffer
		
		AIN SUB RG4 1
		JIF NEZ >GN.ESkip
			MOV RG0 IO
			STR RG0 RG1 1
			ALI ADD RG4 1
		
		#GN.ESkip
		AIN SUB RG4 2
		JIF NEZ >GN.Done
			MOV RG0 IO
			STR RG0 RG1 2
			ALI ADD RG4 1
	
	
	#GN.Done  / Assumes RG4 has the input_heap_pointer (BufferIdx) in it
	STR RG4 RG4 >BuffIdx
	LOD RG7 SP 0
	ALI ADD SP 1
	MOV PC RG7
)

(#AppStrLbl
	
)

(#BuildTables  / First pass through the file, build label table.
	
)

(#Assemble  / Second pass through the file, do the actual assembling.
	
)

(#StopPoint

)

#LabelTable  / The rest of memory is treated as the label table.
/ Structure: (size+1, l, a, b, e, l, value), (size+1, l, a, ...), ...
/ Where size+1 is the relative index of the value, 1 short of the next entry.