JIF TRU >StartPoint

(/ Constants, variables, and tables.
@INFLG = 0
@OUTFLG = 0x800

@TABLESTOP = 0xFFFF  / Must stay NULL.

/ Instruction table entries: (mnemonic_hash, translation, operand_bitmap)
(#InstTable = [0xd188, 0x0000, 0b0000,  / HLT
               0xb672, 0x1000, 0b0000,  / RSM
               0xcf33, 0x2000, 0b0000,  / SYS
               0xd9ed, 0x3000, 0b0011,  / MOV
               0x992a, 0x4000, 0b0100,  / JIF
               0xa48c, 0x5000, 0b0010,  / LDI
               0x91ec, 0x6000, 0b0011,  / LOD
               0xca93, 0x7000, 0b0011,  / STR
               0x9981, 0x8000, 0b0111,  / ALF
               0x9921, 0x9000, 0b1111,  / AIF
               0xd581, 0xA000, 0b0111,  / ALU
               0xa581, 0xB000, 0b1111,  / ALI
               0xb8c1, 0xC000, 0b0111,  / AFN
               0xb921, 0xD000, 0b1111,  / AIN
               0xc1ee, 0xFFFF, 0b0000,  / NOP
               >TABLESTOP
               ])

/ Register table entries: (mnemonic_hash, translation)
(#RegTable = [0x40F2, 0x0,  / RG0
			  0x44F2, 0x1,  / RG1
			  0x48F2, 0x2,  / RG2
			  0x4CF2, 0x3,  / RG3
			  0x50F2, 0x4,  / RG4
			  0x54F2, 0x5,  / RG5
			  0x58F2, 0x6,  / RG6
			  0xD2AF, 0x6,  / OUT
			  0x5CF2, 0x7,  / RG7
			  0x0032, 0x7,  / RA
			  0x0070, 0x8,  / PC
			  0x01E9, 0x9,  / IO
			  0x9D86, 0xA,  / FLG
			  0x0213, 0xB,  / SP
			  0x8988, 0xC,  / HLB
			  0x9283, 0xD,  / CTD
			  0x8E05, 0xE,  / EPC
			  0x8705, 0xF,  / EXA
			  >TABLESTOP
			  ])

/ Modifier table entries: (mnemonic_hash, translation)
(#ModTable = [0xD1EE, 0x0,  / NOT
			  0x91C1, 0x1,  / AND
			  0x024F, 0x2,  / OR
			  0xC9F8, 0x3,  / XOR
			  0x8993, 0x4,  / SLB
			  0x8A53, 0x5,  / SRB
			  0xB0B3, 0x6,  / SEL
			  0x8DC5, 0x7,  / ENC
			  0x9CAE, 0x8,  / NEG
			  0x9081, 0x9,  / ADD
			  0x8C81, 0xA,  / ADC
			  0x8AB3, 0xB,  / SUB
			  0x8853, 0xC,  / SBB
			  0xB2AD, 0xD,  / MUL
			  0xD924, 0xE,  / DIV
			  0x91ED, 0xF,  / MOD

			  0xEA25, 0x0,  / EQZ
			  0xEA8c, 0x1,  / LTZ
			  0xC823, 0x2,  / CAR
			  0xCACF, 0x3,  / OVR
			  0x9250, 0x4,  / PRD
			  0xD2F0, 0x5,  / PWT
			  0xD654, 0x6,  / TRU
			  0x91D2, 0x7,  / RND
			  0xE8AE, 0x8,  / NEZ
			  0xE8A7, 0x9,  / GEZ
			  0xC86E, 0xA,  / NCR
			  0xD9EE, 0xB,  / NOV
			  0xC9D0, 0xC,  / PNR
			  0xDDD0, 0xD,  / PNW
			  >TABLESTOP
			  ])

/ It looks strange, but SkipChars includes newline and tab.
(#SkipChars = [' ', ';', '
', '	', ',', '=', ':', '[', ']', '(', ')', >TABLESTOP])

@COMMENT = '/'
@NEWLINE = '
'
@COMMAND = '%'
@LABEL = '#'
@CONST = '@'
@HEX = 'x'
@BIN = 'b'
@REF = '>'
@CHAR = ''' /' / To make the Notepad++ UDL not do weird things, /' was used here.
@ARRAY = '~'
@STOP = 0


#Buffer = [~128]  / Buffer is buffer
#BuffIdx = 0  / BuffIdx is buffer_index

#LblTblIdx = 0  / LblTblIdx is table_heap_pointer

)

(#StartPoint  / The starting point for the assembler.
	
	/ Write 0 to the input
	LDI RG0 >INFLG; MOV FLG RG0
	ALU AND RG0 0; MOV IO RG0
	
	/ Goto BuildTables
	JIF TRU >BuildTables
)

(#GetValueBase  / UNSAFE for RG1-3, RG0:multiplier, RG1:startIndex, returns value
	/ RG1 = index
	/ RG2 = buffer_index (BuffIdx)
	/ RG3 = next_char
	
	ALI AND RG2 0; LOD RG2 RG2 >BuffIdx  / Get BuffIdx
	ALI AND OUT 0
	
	AFN SUB RG1 RG2; JIF EQZ >GVB.Done  / If it's empty, just return 0.
	
	#GVB.FLoop  / do{
		LOD RG3 RG1 >Buffer  / Get next character (at Buffer[index])
		
		AIN SEL RG3 5; JIF EQZ >GVB.Num  / If it's a letter, add 9 to it.
			ALI ADD RG3 9
		#GVB.Num
		
		ALI AND RG3 0xF  / Mask the character to get the value.
		ALU MUL OUT RG0; ALU ADD OUT RG3  / OUT = OUT * multiplier + value.
		
	ALI ADD RG1 1; AFN SUB RG1 RG2; JIF NEZ >GVB.FLoop  / }for(RG1; RG1 != RG2; RG1++)
	
	#GVB.Done; MOV PC RA  / Return
)

(#GetNumericValue  / UNSAFE for RG0-3, returns value
	/ RG0 = second_char & buffer_index
	/ RG1 = buffer & HEX_CHAR & BIN_CHAR
	
	ALI AND RG0 0; LOD RG0 RG0 >BuffIdx
	
	AIN SUB RG0 1; JIF NEZ >GNV.0  / "it is a 1 digit decimal number"
		ALI AND OUT 0; LOD OUT OUT >Buffer; ALI AND OUT 0xF
		MOV PC RA
	#GNV.0
	
	/Passes control straight to GetValueBase
	
	LDI RG0 1; LOD RG0 RG0 >Buffer; AIN SEL RG0 5; JIF NEZ >GNV.Char  / if bit 5 of Buffer[1] is off
		LDI RG0 10; ALI AND RG1 0; JIF TRU >GetValueBase
	#GNV.Char
	
	LDI RG1 >HEX; AFN SUB RG0 RG1; JIF NEZ >GNV.NH  / if Buffer[1] is HEX
		LDI RG0 16; LDI RG1 2; JIF TRU >GetValueBase
	#GNV.NH
	
	LDI RG1 >BIN; AFN SUB RG0 RG1; JIF NEZ >GNV.Bad  / if Buffer[1] is BIN
		LDI RG0 2; LDI RG1 2; JIF TRU >GetValueBase
	#GNV.Bad
	/ We shouldn't get here, because GetNumericValue is always called on a number.
	
	HLT; 0xFFF0; JIF TRU >StartPoint  / Stop; error code; restart assembler.
)

(#LabelLookup  / UNSAFE for ALL, returns label value
	/ RG0 = index *of* (the 0th element of) the current entry in table
	/ RG1 = table_heap_pointer
	/ RG2 = size (of whole entry - 1 == size of string + 1 == what the buffer_index should be)
	/ RG3 = buffer_index
	/ RG4 = current index *within* the string/entry
	/ RG5 = temp
	
	ALI AND RG0 0
	ALI AND RG1 0; LOD RG1 RG1 >LblTblIdx
	
	#LL.TableLoop
		/ Check if we're out of labels to search through.
		AFN SUB RG0 RG1; JIF LTZ >LL.OK
			/ We should never reach here, because every label searched should exist.
			HLT; 0xFFF1; JIF TRU >StartPoint  / Halt, error code, restart assembler.
		#LL.OK
		
		/ Check if the label is the right size.
		LOD RG2 RG0 >LabelTable; AFN SUB RG3 RG2; JIF NEZ >LL.NotMatch
			LDI RG4 1
			
			/ Loop through both the buffer string and the entry's string at the same time.
			#LL.EntryLoop
				/ If we reach the end of the heap, we have a match (cause they're the same size strings)
				AFN SUB RG4 RG2; JIF NEZ >LL.DoLoop
					ALU ADD RG0 RG2; LOD OUT RG0 >LabelTable; JIF TRU >LL.Done
				#LL.DoLoop
				
				/ If any pair of characters don't match, exit the loop.
				MOV RG5 RG0; ALU ADD RG5 RG4; LOD RG5 RG5 >LabelTable  / RG5 = LabelTable[RG0 + RG4]
				LOD RG6 RG4 >Buffer; AFN SUB RG5 RG6; JIF NEZ >LL.NotMatch  / exit if RG5 != Buffer[RG4]
				
			ALI ADD RG4 1; JIF TRU >LL.EntryLoop  / Increment relative/string index and loop.
		#LL.NotMatch
	ALU ADD RG0 RG2; ALI ADD RG0 1; JIF TRU >LL.TableLoop  / move the table index to the next entry
	
	#LL.Done
	MOV PC RA
)

(#TblIdxLookup  / UNSAFE for RG3-5, RG0:key, RG1:table, RG2:entry_size, returns index
	/ RG3 = index
	/ RG4 = next_entry_key
	/ RG5 = TABLESTOP
	ALI AND RG3 0
	LDI RG5 >TABLESTOP
	
	#TIL.Loop
		STR RG3 RG3 >TIL.SMC; LOD RG4 RG1 #TIL.SMC 0  / next entry = [table + index]
		
		AFN SUB RG4 RG0; JIF NEZ TIL.Skp1  / Check if there's a match
			MOV OUT RG3
			JIF TRU TIL.End
		#TIL.Skp1
		
		AFN SUB RG4 RG5; JIF NEZ TIL.Skp2  / Check if we're at the end of the table.
			MOV OUT RG5
			JIF TRU TIL.End
		#TIL.Skp2
		
		ALU ADD RG3 RG2
	JIF TRU TIL.Loop
	
	#TIL.End
	MOV PC RA
)

(#GotoChar  / UNSAFE for RG5-6, RG0:target
	/ RG5 = char
	/ RG6 = STOP_CHAR
	LDI RG6 >STOP
	
	#GC.Loop
		MOV RG5 IO
		AFN SUB RG5 RG0; JIF EQZ >GC.Done  / If we're at the target, we're done.
	AFN SUB RG5 RG6; JIF NEZ >GC.Loop  / If we hit the end of the file, we're really done.
	
	#GC.Done
	MOV PC RA
)

(#GetNext  / UNSAFE for ALL, RG7:returnAdd
	/ RG0 = char
	/ RG1 = COMMAND_CHAR & COMMENT_CHAR
	/ RG2 = 1 (for table_index_lookup)
	/ RG4 = buffer_index (BuffIdx)
	
	/ Storing the return address on the stack
	ALI SUB SP 1; STR RA SP 0
	LDI RG2 1
	
	/ "Look for the start of a viable sequence"
	#GN.Loop1
		MOV RG0 IO
		LDI RA >GN.Loop1
		
		LDI RG1 >COMMAND; AFN SUB RG0 RG1; JIF EQZ >GotoChar  / If command, goto command (already in RG0)

		LDI RG1 >COMMENT; AFN SUB RG0 RG1; JIF NEZ >GN.L2  / If comment,
			LDI RG0 >NEWLINE; JIF TRU >GotoChar            / Goto newline
		#GN.L2
		
		/ Do TblIdxLookup(char, SkipChars, 1)
		LDI RG1 >SkipChars; LDI RA >GN.Ret1; JIF TRU >TblIdxLookup; #GN.Ret1  
		
	AIN ADD OUT 1; JIF NCR >GN.Loop1  / If TblIdxLookup did not return NULL, loop.
    
	/ "If we hit a stop character, just put that in the input heap"
	LDI RG1 >STOP; ALN SUB RG0 RG1; JIF NEZ >GN.Skip1
		STR RG0 RG0 >Buffer
		LDI RG4 1
		JIF TRU >GN.Done
	#GN.Skip1
	
	ALI AND RG4 0
	
	/ "Else, get the rest of the character sequence"
	#GN.Loop2
		STR RG0 RG4 >Buffer; ALI ADD RG4 1
		
		MOV RG0 IO
		
		LDI RG1 >COMMAND; ALN SUB RG0 RG1; JIF NEZ >GN.LL1
			LDI RG7 >GN.Loop2D; JIF TRU >GotoChar
		#GN.LL1
		
		LDI RG1 >COMMENT; ALN SUB RG0 RG1; JIF NEZ >GN.LL2
			LDI RG0 >NEWLINE
			LDI RG7 >GN.Loop2D; JIF TRU >GotoChar
		#GN.LL2
		
		LDI RG1 >STOP; ALN SUB RG0 RG1; JIF EQZ >GN.Loop2D
		
		/ "if char is a skip character"
			LDI RG1 >SkipChars
			
			/ Preserving RG4 (TblIdxLookup is UNSAFE for that register)
			ALI SUB SP 1: STR RG4 SP 0
			LDI RG7 >GN.LLRet: JIF TRU >TblIdxLookup #GN.LLRet
			LOD RG4 SP 0: ALI ADD SP 1
			
			ALN ADD RG6 1
			JIF CAR >GN.Loop2
	#GN.Loop2D
	
	/ RG0 = buffer[0] & char
	/ RG1 = CHAR_CHAR & buffer (Buffer)
	/ RG4 = buffer_index (BuffIdx)
	
	/ "Check to see if we tried to read a character that was a skip or character character"
	ALI AND RG0 0: LOD RG0 RG0 >Buffer
	LDI RG1 >CHAR
	ALN SUB RG0 RG1
	JIF NEZ >GN.Done
	
		LDI RG1 >Buffer
		
		AIN SUB RG4 1
		JIF NEZ >GN.ESkip
			MOV RG0 IO
			STR RG0 RG1 1
			ALI ADD RG4 1
		
		#GN.ESkip
		AIN SUB RG4 2
		JIF NEZ >GN.Done
			MOV RG0 IO
			STR RG0 RG1 2
			ALI ADD RG4 1
	
	
	#GN.Done  / Assumes RG4 has the buffer_index (BuffIdx) in it
	
	/ Update buffer index and return.
	STR RG4 RG4 >BuffIdx
	LOD RG7 SP 0; ALI ADD SP 1; MOV PC RG7
)

(#ApdStrLbl  / UNSAFE for RG0-3, RG7:returnAdd
	/ RG0 = BuffIdx
	/ RG1 = LblTblIdx
	/ RG2 = index
	/ RG3 = Buffer[index]
	
	ALI AND RG1 0; LOD RG1 RG1 >LblTblIdx
	LDI RG2 1
	
	/ "Add size+1" ...to the table.
	ALI AND RG0 0; LOD RG0 RG0 >BuffIdx; STR RG0 RG1 >LabelTable; ALI ADD RG1 1
	
	/ "Copy in the label string"
	ALN SUB RG2 RG0; JIF EQZ >ASL.Done; #ASL.WLoop
		LOD RG3 RG2 >Buffer; STR RG3 RG1 >LabelTable; ALI ADD RG1 1
		ALI ADD RG2 1
		
		ALN SUB RG2 RG0; JIF NEZ >ASL.WLoop
	#ASL.Done
	
	/ Update the label table index and return.
	STR RG1 RG1 >LblTblIdx
	MOV PC RG7
)

(#HashHeap  / UNSAFE for RG0-1, RG6:output, RG7:returnAdd
	/ RG0 = temp
	/ RG1 = 0x1f (bottom 5 bit mask)
	LDI RG1 0x1F
	ALI AND RG6 0
	
	LDI RG0 2; LOD RG0 RG0 >Buffer; MOV RG6 RG0
	
	ALU AND RG6 RG1; ALI SLB RG6 10
	
	ALI SEL RG0 5; ALI SLB RG0 15; ALU OR RG6 RG0
	
	LDI RG0 1; LOD RG0 RG0 >Buffer
	
	ALU AND RG0 RG1; ALI SLB RG0 5; ALU OR RG6 RG0
	
	ALI AND RG0 0; LOD RG0 RG0 >Buffer
	
	ALU AND RG0 RG1; ALU OR RG6 RG0
	
	MOV PC RG7
)

(#AssembleNext  / UNSAFE for ALL, RG0: table, RG6:output, RG7:returnAdd
	
	ALI SUB SP 2; STR RG0 SP 0; STR RG7 SP 1 / Push table(RG0) and returnAdd(RG7)
	
	LDI RG7 >AN.Ret0; JIF TRU >GetNext; #AN.Ret0  / get_next_text()
	
	ALI AND RG1 0; LOD RG1 RG1 >BuffIdx  / RG1 = buffer_index
	
	AIN SUB RG1 2; JIF NEZ >AN.Skip0  / if buffer_index == 2
		ALI AND RG2 0; LDI RG3 2; STR RG2 RG3 >Buffer  / buffer[2] = 0
		ALI ADD RG1 1; STR RG1 RG1 >BuffIdx  / buffer_index++
	#AN.Skip0
	
	LDI RG7 >AN.Ret1; JIF TRU >HashHeap; #AN.Ret1; MOV RG0 RG6  / RG0 = hash_heap()
	LOD RG1 SP 0 / Copy table to RG1 
	LDI RG2 2  / RG2 = 2
	
	LDI RG7 >AN.Ret2; JIF TRU >TblIdxLookup; #AN.Ret2  / RG6 = TblIdxLookup(hash, table, 2)
	
	ALI ADD RG6 1; LOD RG0 SP 0; ALU ADD RG6 RG0; LOD RG6 RG6 0 / RG6 = [table + RG6 + 1] = table[Idx + 1]
	LOD RG7 SP 1; ALI ADD SP 2; MOV PC RG7 / Pop from stack and return
)

(#BuildTables  / First pass through the file, build label table.

	ALI AND RG0 0  / program_counter(RG0) = 0
	ALI SUB SP 1; STR RG0 SP 0  / Push the program counter onto the stack.
	#BT.Loop
		/ "Place the next chunk of admissible text into the heap."
		LDI RG7 >BT.Ret0; JIF TRU >GetNext; #BT.Ret0  / GetNext()
		ALI AND RG0 0; LOD RG0 RG0 >Buffer  / RG0 = first character in buffer
		
		/ "Check what type of admissible string it is."
		LDI RG1 >STOP; ALN SUB RG0 RG1; JIF EQZ >BT.Done  / "We're done"
		
		LDI RG1 >LABEL; ALN SUB RG0 RG1; JIF NEZ >BT.Skip0  / "It's a label"
			/ "Add the label to the table."
			LDI RG7 >BT.Ret1; JIF TRU >ApdStrLbl; #BT.Ret1
			
			/ "Add the value to the table."
			LOD RG0 SP 0; ALI AND RG1 0; LOD RG1 RG1 >LblTblIdx; STR RG0 RG1 >LabelTable
			ALI ADD RG1 1; STR RG1 RG1 >LblTblIdx  / LblTblIdx++
			JIF TRU >BT.Loop
		#BT.Skip0
		
		LDI RG1 >CONST; ALN SUB RG0 RG1; JIF NEZ >BT.Skip1  / "It's a constant"
			/ "Add the label to the table."
			LDI RG7 >BT.Ret2; JIF TRU >ApdStrLbl; #BT.Ret2
			
			/ "Get the constant's text value."
			LDI RG7 >BT.Ret3; JIF TRU >GetNext; #BT.Ret3
			
			/ "Get and store the value of the label."
			LDI RG7 >BT.Ret4; JIF TRU >GetNumericValue; #BT.Ret4
			ALI AND RG0 0;
		#BT.Skip1
		
		
)

(#Assemble  / Second pass through the file, do the actual assembling.
	
)

(#StopPoint

)

#LabelTable
/ The rest of memory is treated as the label table.
/ Structure: (size+1, l, a, b, e, l, value), (size+1, l, a, ...), ...
/ Where size+1 is the relative index of the value, 1 short of the next entry.
/ It also happens to be the value that BuffIdx should be if the buffer contents match the label.